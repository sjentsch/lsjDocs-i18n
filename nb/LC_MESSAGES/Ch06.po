#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PROJECT VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-03-17 16:23+0100\n"
"PO-Revision-Date: 2024-08-13 16:56+0000\n"
"Last-Translator: Sebastian Jentschke <sebastian.jentschke@uib.no>\n"
"Language-Team: Norwegian Bokmål <https://hosted.weblate.org/projects/lsjdocs/"
"ch06/nb_NO/>\n"
"Language: nb\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=n != 1;\n"
"X-Generator: Weblate 5.7-dev\n"
"Generated-By: Babel 2.15.0\n"

#: ../../Ch06/Ch06_DataHandling.rst:4
msgid "Pragmatic matters"
msgstr "Pragmatiske spørsmål"

#: ../../Ch06/Ch06_DataHandling.rst:20
msgid ""
"*The garden of life never seems to confine itself to the plots philosophers "
"have laid out for its convenience. Maybe a few more tractors would do the "
"trick.*"
msgstr ""
"*Livets hage ser aldri ut til å begrense seg til de parsellene filosofene "
"har anlagt for dens bekvemmelighet. Kanskje noen traktorer ville gjøre susen."
"*"

#: ../../Ch06/Ch06_DataHandling.rst:24
msgid "Roger Zelazny (Home is the Hangman, 1975)"
msgstr "Roger Zelazny (Home is the Hangman, 1975)"

#: ../../Ch06/Ch06_DataHandling.rst:27
msgid ""
"This is a somewhat strange chapter, even by my standards. My goal in this "
"chapter is to talk a bit more honestly about the realities of working with "
"data than you’ll see anywhere else in the book. The problem with real world "
"data sets is that they are *messy*. Very often the data file that you start "
"out with doesn’t have the variables stored in the right format for the "
"analysis you want to do. Sometimes there might be a lot of missing values in "
"your data set. Sometimes you only want to analyse a subset of the data. Et "
"cetera. In other words, there’s a lot of **data manipulation** that you need "
"to do just to get the variables in your data set into the format that you "
"need it. The purpose of this chapter is to provide a basic introduction to "
"these pragmatic topics. Although the chapter is motivated by the kinds of "
"practical issues that arise when manipulating real data, I’ll stick with the "
"practice that I’ve adopted through most of the book and rely on very small, "
"toy data sets that illustrate the underlying issue. Because this chapter is "
"essentially a collection of techniques and doesn’t tell a single coherent "
"story, it may be useful to start with a list of topics:"
msgstr ""
"Dette er et litt merkelig kapittel, selv etter mine standarder. Målet mitt i "
"dette kapittelet er å snakke litt mer ærlig om realitetene ved å jobbe med "
"data enn du vil se noe annet sted i boken. Problemet med virkelige datasett "
"er at de er *knotete*. Svært ofte har ikke datafilen du starter med, "
"variablene lagret i riktig format for den analysen du ønsker å gjøre. Noen "
"ganger kan det være mange manglende verdier i datasettet. Noen ganger ønsker "
"du bare å analysere en delmengde av dataene. Og så videre. Med andre ord er "
"det mye **datamanipulering** du må gjøre bare for å få variablene i "
"datasettet ditt inn i det formatet du trenger. Formålet med dette kapittelet "
"er å gi en grunnleggende innføring i disse pragmatiske temaene. Selv om "
"kapittelet er motivert av de praktiske problemene som oppstår når man "
"manipulerer virkelige data, vil jeg holde meg til den praksisen jeg har "
"brukt gjennom det meste av boken, og ta utgangspunkt i svært små, fiktive "
"datasett som illustrerer det underliggende problemet. Fordi dette kapittelet "
"i hovedsak er en samling teknikker og ikke forteller én sammenhengende "
"historie, kan det være nyttig å starte med en liste over emner:"

#: ../../Ch06/Ch06_DataHandling.rst:45
msgid ":doc:`Ch06_DataHandling_1`"
msgstr ":doc:`Ch06_DataHandling_1`"

#: ../../Ch06/Ch06_DataHandling.rst:47
msgid ":doc:`Ch06_DataHandling_2`"
msgstr ":doc:`Ch06_DataHandling_2`"

#: ../../Ch06/Ch06_DataHandling.rst:49
msgid ":doc:`Ch06_DataHandling_3`"
msgstr ":doc:`Ch06_DataHandling_3`"

#: ../../Ch06/Ch06_DataHandling.rst:51
msgid ":doc:`Ch06_DataHandling_4`"
msgstr ":doc:`Ch06_DataHandling_4`"

#: ../../Ch06/Ch06_DataHandling.rst:53
msgid ":doc:`Ch06_DataHandling_5`"
msgstr ":doc:`Ch06_DataHandling_5`"

#: ../../Ch06/Ch06_DataHandling.rst:55
msgid ""
"As you can see, the list of topics that the chapter covers is pretty broad, "
"and there’s a *lot* of content there. Even though this is one of the longest "
"and hardest chapters in the book, I’m really only scratching the surface of "
"several fairly different and important topics. My advice, as usual, is to "
"read through the chapter once and try to follow as much of it as you can. "
"Don’t worry too much if you can’t grasp it all at once, especially the later "
"sections. The rest of the book is only lightly reliant on this chapter so "
"you can get away with just understanding the basics. However, what you’ll "
"probably find is that later on you’ll need to flick back to this chapter in "
"order to understand some of the concepts that I refer to here."
msgstr ""
"Som du kan se, er listen over emner som kapitlet dekker ganske bred, og det "
"er *mye* innhold der. Selv om dette er et av de lengste og vanskeligste "
"kapitlene i boken, skraper jeg egentlig bare i overflaten av flere ganske "
"forskjellige og viktige temaer. Mitt råd er som vanlig å lese gjennom "
"kapittelet én gang og prøve å få med deg så mye som mulig av det. Ikke tenk "
"for mye på om du ikke får med deg alt på en gang, særlig ikke de siste "
"avsnittene. Resten av boken er bare i liten grad avhengig av dette "
"kapittelet, så du kan klare deg med bare å forstå det grunnleggende. Men "
"senere vil du sannsynligvis oppdage at du må bla tilbake til dette "
"kapittelet for å forstå noen av de begrepene jeg refererer til her."

#: ../../Ch06/Ch06_DataHandling_1.rst:4
msgid "Tabulating and cross-tabulating data"
msgstr "Tabulering og krysstabulering av data"

#: ../../Ch06/Ch06_DataHandling_1.rst:6
msgid ""
"A very common task when analysing data is the construction of frequency "
"tables, or cross-tabulation of one variable against another. These tasks can "
"be achieved in jamovi and I’ll show you how in this section."
msgstr ""
"En svært vanlig oppgave når man analyserer data, er å lage frekvenstabeller "
"eller krysstabeller av en variabel mot en annen. Disse oppgavene kan utføres "
"i jamovi, og jeg skal vise deg hvordan du gjør det i denne delen."

#: ../../Ch06/Ch06_DataHandling_1.rst:11
msgid "Creating tables for single variables"
msgstr "Opprette tabeller for enkeltvariabler"

#: ../../Ch06/Ch06_DataHandling_1.rst:13
msgid ""
"Let’s start with a simple example. As a parent of a small child I naturally "
"spend a lot of time watching TV shows like *In the Night Garden*. In the |"
"nightgarden|_ data set, I’ve transcribed a short section of the dialogue. "
"The file contains two variables of interest, ``speaker`` and ``utterance``. "
"Open up this data set in jamovi and take a look at the data in the ``Data`` "
"view. You will see that the data looks something like this:"
msgstr ""
"La oss begynne med et enkelt eksempel. Som småbarnsforelder bruker jeg "
"naturlig nok mye tid på å se på TV-serier som *In the Night Garden*. I "
"datasettet |nightgarden|_ har jeg transkribert en kort del av dialogen. "
"Filen inneholder to interessante variabler, ``speaker`` og ``utterance``. "
"Åpne dette datasettet i jamovi og ta en titt på dataene i ``Data``-"
"visningen. Du vil se at dataene ser omtrent slik ut:"

#: ../../Ch06/Ch06_DataHandling_1.rst:20
msgid "``speaker`` variable"
msgstr "Variabelen ``speaker``"

#: ../../Ch06/Ch06_DataHandling_1.rst:26
msgid "``utterance`` variable"
msgstr "Variabelen ``utterance``"

#: ../../Ch06/Ch06_DataHandling_1.rst:33
msgid ""
"Looking at this it becomes very clear what happened to my sanity! With these "
"as my data, one task I might find myself needing to do is construct a "
"frequency count of the number of words each character speaks during the "
"show. The jamovi ``Descriptives`` screen has a check box called ``Frequency "
"tables`` which does just this, see :numref:`fig-freqtable`."
msgstr ""
"Når man ser på dette, blir det veldig tydelig hva som skjedde med forstanden "
"min! Med disse dataene som datagrunnlag, kan det hende jeg får behov for å "
"konstruere en frekvenstelling av antall ord hver karakter sier i løpet av "
"serien. Skjermbildet jamovi ``Descriptives`` har en avmerkingsboks som heter "
"``Frequency tables`` som gjør nettopp dette, se :numref:`fig-freqtable`."

#: ../../Ch06/Ch06_DataHandling_1.rst:41 ../../Ch06/Ch06_DataHandling_1.rst:45
msgid "Frequency table for the ``speaker`` variable"
msgstr "Frekvenstabell for variabelen ``speaker``"

#: ../../Ch06/Ch06_DataHandling_1.rst:49
msgid ""
"The output here tells us on the first line that what we’re looking at is a "
"tabulation of the ``speaker`` variable. In the ``Levels`` column it lists "
"all the different speakers that exist in the data, and in the ``Counts`` "
"column it tells you how many times that speaker appears in the data. In "
"other words, it’s a frequency table."
msgstr ""
"Utgaven her forteller oss på første linje at det vi ser på, er en tabell "
"over variabelen ``speaker``. I kolonnen ``Levels`` listes alle de ulike "
"talerne som finnes i dataene, og i kolonnen ``Counts`` står det hvor mange "
"ganger den aktuelle taleren forekommer i dataene. Det er med andre ord en "
"frekvenstabell."

#: ../../Ch06/Ch06_DataHandling_1.rst:55
msgid ""
"In jamovi, the ``Frequency tables`` check box will only produce a table for "
"single variables. For a table of two variables, for example combining "
"``speaker`` and ``utterance`` so that we can see how many times each speaker "
"said a particular utterance, we need a cross-tabulation or contingency "
"table. In jamovi you can do this by selecting the ``Frequencies`` → "
"``Contingency Tables`` → ``Independent Samples`` analysis, and moving the "
"``speaker`` variable into the ``Rows`` box, and the ``utterance`` variable "
"into the ``Columns`` box. You then should have a contingency table like the "
"one shown in :numref:`fig-contingencytable`."
msgstr ""
"I jamovi vil avkrysningsboksen ``Frequency tables`` bare produsere en tabell "
"for enkeltvariabler. For en tabell med to variabler, for eksempel en "
"kombinasjon av ``speaker`` og ``utterance``, slik at vi kan se hvor mange "
"ganger hver taler gjorde en bestemt ytring, trenger vi en krysstabell "
"(*contingency table*). I jamovi kan du gjøre dette ved å velge analysen "
"``Frequencies`` → ``Contingency Tables`` → ``Independent Samples`` og flytte "
"variabelen ``speaker`` til ``Rows``-variableboksen, og variabelen "
"``utterance`` til ``Columns``-variableboksen. Du bør da ha en krysstabell "
"som den som vises i :numref:`fig-contingencytable`."

#: ../../Ch06/Ch06_DataHandling_1.rst:67
msgid "Contingency table for ``speaker`` and ``utterance``"
msgstr "Krysstabell for ``speaker`` og ``utterance``"

#: ../../Ch06/Ch06_DataHandling_1.rst:71
msgid "Contingency table for the ``speaker`` and ``utterance`` variables"
msgstr "Krysstabell for variablene ``speaker`` og ``utterance``"

#: ../../Ch06/Ch06_DataHandling_1.rst:75
msgid ""
"Don’t worry about the ``χ² Tests`` table that is produced. We are going to "
"cover this later on in chapter :doc:`../Ch10/Ch10_ChiSquare`. When "
"interpreting the contingency table remember that these are counts, so the "
"fact that the first row and second column of numbers corresponds to a value "
"of 2 indicates that ``makka-pakka`` (row 1) says ``onk`` (column 2) twice in "
"this data set."
msgstr ""
"Ikke bry deg om tabellen ``χ² Tests`` som blir produsert. Vi kommer til å "
"dekke dette senere i kapittel :doc:`../Ch10/Ch10_ChiSquare`. Når du tolker "
"krysstabellen, må du huske at dette er tellinger, så det faktum at den "
"første raden og den andre kolonnen med tall tilsvarer verdien 2, betyr at "
"``makka-pakka`` (rad 1) sier ``onk`` (kolonne 2) to ganger i dette "
"datasettet."

#: ../../Ch06/Ch06_DataHandling_1.rst:82
msgid "Adding percentages to a contingency table"
msgstr "Legge til prosentandeler i en krysstabell"

#: ../../Ch06/Ch06_DataHandling_1.rst:84
msgid ""
"The contingency table shown in :numref:`fig-contingencytable` shows a table "
"of raw frequencies. That is, a count of the total number of cases for "
"different combinations of levels of the specified variables. However, often "
"you want your data to be organised in terms of percentages as well as "
"counts. You can find the check boxes for different percentages under the "
"``Cells`` option in the ``Contingency Tables`` window. First, click on the "
"``Row`` check box and the Contingency Table in the output window will change "
"to the one in :numref:`fig-contingencyrow`."
msgstr ""
"Krysstabellen som vises i :numref:`fig-contingencytable`, viser en tabell "
"med råfrekvenser. Det vil si en opptelling av det totale antallet tilfeller "
"for ulike kombinasjoner av nivåer av de angitte variablene. Ofte ønsker man "
"imidlertid å organisere dataene i form av prosentandeler i tillegg til "
"antall. Du finner avmerkingsboksene for ulike prosentandeler under "
"alternativet ``Cells`` i analysevinduet for ``Contingency Tables``. Klikk "
"først på avmerkingsboksen ``Row``, så endres krysstabellen (``Contingency "
"Table``) i utgavevinduet til den du finner i :numref:`fig-contingencyrow`."

#: ../../Ch06/Ch06_DataHandling_1.rst:95
msgid ""
"Contingency table with row percentages for ``speaker`` and ``utterance``"
msgstr "Krysstabell med radprosenter for ``speaker`` og ``utterance``"

#: ../../Ch06/Ch06_DataHandling_1.rst:99
msgid ""
"Contingency table for the ``speaker`` and ``utterance`` variables, with row "
"percentages"
msgstr ""
"Krysstabell for variablene ``speaker`` og ``utterance``, med prosentandeler "
"for hver rad"

#: ../../Ch06/Ch06_DataHandling_1.rst:104
msgid ""
"What we’re looking at here is the percentage of utterances made by each "
"character. In other words, 50\\% of ``makka-pakka``’s utterances are "
"``pip``, and the other 50\\% are ``onk``. Let’s contrast this with the table "
"we get when we calculate column percentages (uncheck ``Row`` and check "
"``Column`` in the ``Cells`` options window), see :numref:`fig-"
"contingencycol`. In this version, what we’re seeing is the percentage of "
"characters associated with each utterance. For instance, whenever the "
"utterance ``ee`` is made (in this data set), 100\\% of the time it’s a "
"Tombliboo saying it."
msgstr ""
"Det vi ser på her, er prosentandelen av ytringer fra hvert tegn. Med andre "
"ord, 50\\% av ``makka-pakka`` sine ytringer er ``pip``, og de resterende 50\\"
"% er ``onk``. La oss sammenligne dette med tabellen vi får når vi beregner "
"kolonneprosenter (fjern merket for ``Row`` og kryss av for ``Column`` i "
"``Cells``-alternativvinduet), se :numref:`fig-contingencycol`. I denne "
"versjonen er det vi ser prosentandelen tegn som er knyttet til hver ytring. "
"For eksempel, når ytringen ``ee`` blir sagt (i dette datasettet), er det i "
"100\\% av tilfellene en Tombliboo som sier det."

#: ../../Ch06/Ch06_DataHandling_1.rst:115
msgid ""
"Contingency table with column percentages for ``speaker`` and ``utterance``"
msgstr "Krysstabell med kolonneprosenter for ``speaker`` og ``utterance``"

#: ../../Ch06/Ch06_DataHandling_1.rst:119
msgid ""
"Contingency table for the ``speaker`` and ``utterance`` variables, with "
"column percentages"
msgstr ""
"Krysstabell for variablene ``speaker`` og ``utterance``, med kolonneprosenter"

#: ../../Ch06/Ch06_DataHandling_2.rst:4
msgid "Logical expressions in jamovi"
msgstr "Logiske uttrykk i jamovi"

#: ../../Ch06/Ch06_DataHandling_2.rst:6
msgid ""
"A key concept that a lot of data transformations in jamovi rely on is the "
"idea of a **logical value**. A logical value is an assertion about whether "
"something is true or false. This is implemented in jamovi in a pretty "
"straightforward way. There are two logical values, namely ``TRUE`` and "
"``FALSE``. Despite the simplicity, logical values are very useful things. "
"Let’s see how they work."
msgstr ""
"Et nøkkelbegrep som mange datatransformasjoner i jamovi baserer seg på, er "
"ideen om en **logisk verdi**. En logisk verdi er en påstand om hvorvidt noe "
"er sant eller usant. Dette er implementert i jamovi på en ganske enkel måte. "
"Det finnes to logiske verdier, nemlig ``TRUE`` og ``FALSE``. Til tross for "
"enkelheten er logiske verdier svært nyttige. La oss se hvordan de fungerer."

#: ../../Ch06/Ch06_DataHandling_2.rst:14
msgid "Assessing mathematical truths"
msgstr "Vurdering av matematiske sannheter"

#: ../../Ch06/Ch06_DataHandling_2.rst:16
msgid ""
"In George Orwell’s classic book *1984* one of the slogans used by the "
"totalitarian Party was “two plus two equals five”. The idea being that the "
"political domination of human freedom becomes complete when it is possible "
"to subvert even the most basic of truths. It’s a terrifying thought, "
"especially when the protagonist Winston Smith finally breaks down under "
"torture and agrees to the proposition. “Man is infinitely malleable”, the "
"book says. I’m pretty sure that this isn’t true of humans\\ [#]_ and it’s "
"definitely not true of jamovi. jamovi is not infinitely malleable, it has "
"rather firm opinions on the topic of what is and isn’t true, at least as "
"regards basic mathematics. If I ask it to calculate ``2 + 2``,\\ [#]_ it "
"always gives the same answer, and it’s not bloody 5!"
msgstr ""
"I George Orwells klassiske bok *1984* var et av slagordene som ble brukt av "
"det totalitære partiet «to pluss to er fem». Tanken er at det politiske "
"herredømmet over menneskets frihet blir fullstendig når det er mulig å "
"undergrave selv de mest grunnleggende sannheter. Det er en skremmende tanke, "
"særlig når hovedpersonen Winston Smith til slutt bryter sammen under tortur "
"og går med på forslaget. «Mennesket er uendelig formbart», står det i boken. "
"Jeg er ganske sikker på at dette ikke gjelder for mennesker\\ [#]_, og det "
"gjelder definitivt ikke for jamovi. jamovi er ikke uendelig formbar, den har "
"ganske faste meninger om hva som er sant og ikke sant, i hvert fall når det "
"gjelder grunnleggende matematikk. Hvis jeg ber den regne ut ``2 + 2``,\\ "
"[#]_ gir den alltid det samme svaret, og det er faen ikke 5!"

#: ../../Ch06/Ch06_DataHandling_2.rst:29
msgid ""
"Of course, so far jamovi is just doing the calculations. I haven’t asked it "
"to explicitly assert that ``2 + 2 = 4`` is a true statement. If I want "
"jamovi to make an explicit judgement, I can use a command like this: ``2 + 2 "
"== 4``"
msgstr ""
"Så langt gjør jamovi selvfølgelig bare utregningene. Jeg har ikke bedt den "
"om eksplisitt å hevde at ``2 + 2 = 4`` er et sant utsagn. Hvis jeg vil at "
"jamovi skal felle en eksplisitt dom, kan jeg bruke en kommando som denne: "
"``2 + 2 == 4``"

#: ../../Ch06/Ch06_DataHandling_2.rst:34
msgid ""
"What I’ve done here is use the **equality operator**, ``==``, to force "
"jamovi to make a “``TRUE`` or ``FALSE``” judgement.\\ [#]_ Okay, let’s see "
"what jamovi thinks of the Party slogan, so type this into the compute new "
"variable ``Formula`` box:"
msgstr ""
"Det jeg har gjort her er å bruke **likhetsoperatoren**, ``==``, for å tvinge "
"jamovi til å gjøre en «``TRUE`` eller ``FALSE``»-vurdering.\\ [#]_ Ok, la "
"oss se hva jamovi synes om partiets slagord, så skriv dette inn i boksen for "
"beregning av ny variabel ``Formula``:"

#: ../../Ch06/Ch06_DataHandling_2.rst:43
msgid ""
"And what do you get? It should be a whole set of ``FALSE`` values in the "
"spreadsheet column for your newly computed variable. Booyah! Freedom and "
"ponies for all! Or something like that. Anyway, it was worth having a look "
"at what happens if I try to *force* jamovi to believe that two plus two is "
"five by making a statement like ``2 + 2 = 5``. I know that if I do this in "
"another program, say ``R``, then it throws up an error message. But wait, if "
"you do this in jamovi you get a whole set of ``FALSE`` values. So what is "
"going on? Well, it seems that jamovi is being pretty smart and realises that "
"you are testing whether it is ``TRUE`` or ``FALSE`` that ``2 + 2 = 5``, "
"regardless of whether you use the correct **equality operator**, ``==``, or "
"the equals sign ``=``."
msgstr ""
"Og hva får du ut av det? Du får et helt sett med ``FALSE``-verdier i "
"regnearkkolonnen for den nyberegnede variabelen din. Booyah! Frihet og "
"ponnier til alle! Eller noe i den stilen. Uansett, det var verdt å se på hva "
"som skjer hvis jeg prøver å *tvinge* jamovi til å tro at to pluss to er fem "
"ved å komme med en setning som ``2 + 2 = 5``. Jeg vet at hvis jeg gjør dette "
"i et annet program, for eksempel ``R``, så kommer det opp en feilmelding. "
"Men vent, hvis du gjør dette i jamovi, får du et helt sett med ``FALSE``-"
"verdier. Så hva er det som skjer? Vel, det ser ut til at jamovi er ganske "
"smart og skjønner at du tester om det er ``TRUE`` eller ``FALSE`` at ``2 + 2 "
"= 5``, uavhengig av om du bruker den korrekte **likhetsoperatoren**, ``==``, "
"eller likhetstegnet ``=``."

#: ../../Ch06/Ch06_DataHandling_2.rst:56
msgid "Logical operations"
msgstr "Logiske operasjoner"

#: ../../Ch06/Ch06_DataHandling_2.rst:58
msgid ""
"So now we’ve seen logical operations at work. But so far we’ve only seen the "
"simplest possible example. You probably won’t be surprised to discover that "
"we can combine logical operations with other operations and functions in a "
"more complicated way, like this:"
msgstr ""
"Nå har vi sett logiske operasjoner i arbeid. Men så langt har vi bare sett "
"det enkleste eksemplet. Du vil sikkert ikke bli overrasket over å oppdage at "
"vi kan kombinere logiske operasjoner med andre operasjoner og funksjoner på "
"en mer komplisert måte, som dette:"

#: ../../Ch06/Ch06_DataHandling_2.rst:67
msgid "or this"
msgstr "eller dette"

#: ../../Ch06/Ch06_DataHandling_2.rst:73
msgid ""
"Not only that, but as :numref:`tab-logicals` illustrates, there are several "
"other logical operators that you can use corresponding to some basic "
"mathematical concepts. Hopefully these are all pretty self-explanatory. For "
"example, the **less than** operator ``<`` checks to see if the number on the "
"left is less than the number on the right. If it’s less, then jamovi returns "
"an answer of ``TRUE``, but if the two numbers are equal, or if the one on "
"the right is larger, then jamovi returns an answer of ``FALSE``."
msgstr ""
"Ikke bare det, men som :numref:`tab-logicals` illustrerer, finnes det flere "
"andre logiske operatorer som du kan bruke, og som tilsvarer noen "
"grunnleggende matematiske begreper. Forhåpentligvis er alle disse ganske "
"selvforklarende. For eksempel sjekker **mindre enn**-operatoren ``<`` om "
"tallet til venstre er mindre enn tallet til høyre. Hvis det er mindre, "
"returnerer jamovi svaret ``TRUE``, men hvis de to tallene er like, eller "
"hvis tallet til høyre er større, returnerer jamovi svaret ``FALSE``."

#: ../../Ch06/Ch06_DataHandling_2.rst:81
msgid ""
"Some logical operators. Technically I should be calling these “binary "
"relational operators”, but quite frankly I don’t want to. It’s my book so no-"
"one can make me."
msgstr ""
"Noen logiske operatorer. Egentlig burde jeg kalle disse «binære relasjonelle "
"operatorer», men det har jeg ærlig talt ikke lyst til. Det er min bok, så "
"ingen kan tvinge meg."

#: ../../Ch06/Ch06_DataHandling_2.rst:87 ../../Ch06/Ch06_DataHandling_2.rst:137
msgid "operation"
msgstr "drift"

#: ../../Ch06/Ch06_DataHandling_2.rst:87 ../../Ch06/Ch06_DataHandling_2.rst:137
msgid "operator"
msgstr "operatør"

#: ../../Ch06/Ch06_DataHandling_2.rst:87 ../../Ch06/Ch06_DataHandling_2.rst:137
msgid "example input"
msgstr "eksempel på input"

#: ../../Ch06/Ch06_DataHandling_2.rst:87 ../../Ch06/Ch06_DataHandling_2.rst:137
msgid "answer"
msgstr "svar"

#: ../../Ch06/Ch06_DataHandling_2.rst:89
msgid "less than"
msgstr "mindre enn"

#: ../../Ch06/Ch06_DataHandling_2.rst:89
msgid "``<``"
msgstr "``<``"

#: ../../Ch06/Ch06_DataHandling_2.rst:89
msgid "``2 < 3``"
msgstr "``2 < 3``"

#: ../../Ch06/Ch06_DataHandling_2.rst:89 ../../Ch06/Ch06_DataHandling_2.rst:91
#: ../../Ch06/Ch06_DataHandling_2.rst:95 ../../Ch06/Ch06_DataHandling_2.rst:99
#: ../../Ch06/Ch06_DataHandling_2.rst:141
msgid "``TRUE``"
msgstr "``TRUE``"

#: ../../Ch06/Ch06_DataHandling_2.rst:91
msgid "less than or equal to"
msgstr "mindre enn eller lik"

#: ../../Ch06/Ch06_DataHandling_2.rst:91
msgid "``<=``"
msgstr "``<=``"

#: ../../Ch06/Ch06_DataHandling_2.rst:91
msgid "``2 <= 2``"
msgstr "``2 <= 2``"

#: ../../Ch06/Ch06_DataHandling_2.rst:93
msgid "greater than"
msgstr "større enn"

#: ../../Ch06/Ch06_DataHandling_2.rst:93
msgid "``>``"
msgstr "``>``"

#: ../../Ch06/Ch06_DataHandling_2.rst:93
msgid "``2 > 3``"
msgstr "``2 > 3``"

#: ../../Ch06/Ch06_DataHandling_2.rst:93 ../../Ch06/Ch06_DataHandling_2.rst:97
#: ../../Ch06/Ch06_DataHandling_2.rst:139
#: ../../Ch06/Ch06_DataHandling_2.rst:143
msgid "``FALSE``"
msgstr "``FALSE``"

#: ../../Ch06/Ch06_DataHandling_2.rst:95
msgid "greater than or equal to"
msgstr "større enn eller lik"

#: ../../Ch06/Ch06_DataHandling_2.rst:95
msgid "``>=``"
msgstr "``>=``"

#: ../../Ch06/Ch06_DataHandling_2.rst:95
msgid "``2 >= 2``"
msgstr "``2 >= 2``"

#: ../../Ch06/Ch06_DataHandling_2.rst:97
msgid "equal to"
msgstr "lik"

#: ../../Ch06/Ch06_DataHandling_2.rst:97
msgid "``==``"
msgstr "``==``"

#: ../../Ch06/Ch06_DataHandling_2.rst:97
msgid "``2 == 3``"
msgstr "``2 == 3``"

#: ../../Ch06/Ch06_DataHandling_2.rst:99
msgid "not equal to"
msgstr "ikke lik"

#: ../../Ch06/Ch06_DataHandling_2.rst:99
msgid "``!=``"
msgstr "``!=``"

#: ../../Ch06/Ch06_DataHandling_2.rst:99
msgid "``2 != 3``"
msgstr "``2 != 3``"

#: ../../Ch06/Ch06_DataHandling_2.rst:103
msgid ""
"In contrast, the **less than or equal to** operator ``<=`` will do exactly "
"what it says. It returns a value of ``TRUE`` if the number of the left hand "
"side is less than or equal to the number on the right hand side. At this "
"point I hope it’s pretty obvious what the **greater than** operator ``>`` "
"and the **greater than or equal to** operator ``>=`` do!"
msgstr ""
"Operatoren **mindre enn eller lik** ``<=`` vil derimot gjøre akkurat det den "
"sier. Den returnerer verdien ``TRUE`` hvis tallet på venstre side er mindre "
"enn eller lik tallet på høyre side. Nå håper jeg det er ganske åpenbart hva "
"**større enn**-operatoren ``>`` og **større enn eller lik**-operatoren "
"``>=`` gjør!"

#: ../../Ch06/Ch06_DataHandling_2.rst:109
msgid ""
"Next on the list of logical operators is the **not equal to** operator ``!"
"=`` which, as with all the others, does what it says it does. It returns a "
"value of ``TRUE`` when things on either side are not identical to each "
"other. Therefore, since ``2 + 2`` isn’t equal to *5* we would get ``TRUE`` "
"as the value for our newly computed variable. Try it and see:"
msgstr ""
"Den neste på listen over logiske operatorer er **ikke lik**-operatoren ``!"
"=`` som, i likhet med alle de andre, gjør det den sier at den gjør. Den "
"returnerer verdien ``TRUE`` når ting på hver side ikke er identiske med "
"hverandre. Siden ``2 + 2`` ikke er lik *5*, vil vi derfor få ``TRUE`` som "
"verdi for den nyberegnede variabelen vår. Prøv det og se:"

#: ../../Ch06/Ch06_DataHandling_2.rst:119
msgid ""
"We’re not quite done yet. There are three more logical operations that are "
"worth knowing about, listed in :numref:`tab-logicals2`. These are the "
"**not** operator ``!``, the **and**-operator ``and``, and the **or**-"
"operator ``or``. Like the other logical operators, their behaviour is more "
"or less exactly what you’d expect given their names. For instance, if I ask "
"you to assess the claim that “either ``2 + 2 = 4`` *or* ``2 + 2 = 5``” you’d "
"say that it’s true. Since it’s an “either-or” statement, all we need is for "
"one of the two parts to be true. That’s what the ``or`` operator does:\\ [#]_"
msgstr ""
"Vi er ikke helt ferdige ennå. Det er tre logiske operasjoner til som det er "
"verdt å kjenne til, listet opp i :numref:`tab-logicals2`. Disse er **ikke**-"
"operatoren ``!``, **og**-operatoren ``and``, og **eller**-operatoren ``or``. "
"I likhet med de andre logiske operatorene oppfører de seg mer eller mindre "
"nøyaktig slik du forventer ut fra navnene deres. Hvis jeg for eksempel ber "
"deg vurdere påstanden «enten ``2 + 2 = 4`` *eller* ``2 + 2 = 5``», vil du si "
"at den er sann. Siden det er en «enten-eller»-påstand, trenger vi bare at en "
"av de to delene er sann. Det er det ``or``-operatoren gjør:\\ [#]_"

#: ../../Ch06/Ch06_DataHandling_2.rst:133
msgid "Some more logical operators."
msgstr "Noen flere logiske operatorer."

#: ../../Ch06/Ch06_DataHandling_2.rst:139
msgid "not"
msgstr "ikke"

#: ../../Ch06/Ch06_DataHandling_2.rst:139
msgid "``NOT``"
msgstr "``NOT``"

#: ../../Ch06/Ch06_DataHandling_2.rst:139
msgid "``NOT(1==1)``"
msgstr "``NOT(1==1)``"

#: ../../Ch06/Ch06_DataHandling_2.rst:141
msgid "or"
msgstr "eller"

#: ../../Ch06/Ch06_DataHandling_2.rst:141
msgid "``or``"
msgstr "``or``"

#: ../../Ch06/Ch06_DataHandling_2.rst:141
msgid "``(1==1) or (2==3)``"
msgstr "``(1==1) or (2==3)``"

#: ../../Ch06/Ch06_DataHandling_2.rst:143
msgid "and"
msgstr "og"

#: ../../Ch06/Ch06_DataHandling_2.rst:143
msgid "``and``"
msgstr "``and``"

#: ../../Ch06/Ch06_DataHandling_2.rst:143
msgid "``(1==1) and (2==3)``"
msgstr "``(1==1) and (2==3)``"

#: ../../Ch06/Ch06_DataHandling_2.rst:146
msgid ""
"On the other hand, if I ask you to assess the claim that “both 2 + 2 = 4 "
"*and* 2 + 2 = 5” you’d say that it’s false. Since this is an *and* statement "
"we need both parts to be true. And that’s what the ``and`` operator does:"
msgstr ""
"Hvis jeg derimot ber deg vurdere påstanden «både 2 + 2 = 4 *og* 2 + 2 = 5», "
"vil du si at den er usann. Siden dette er et *og* utsagn, må begge delene "
"være sanne. Og det er det operatoren ``and`` gjør:"

#: ../../Ch06/Ch06_DataHandling_2.rst:154
msgid ""
"Finally, there’s the *not* operator, which is simple but annoying to "
"describe in English. If I ask you to assess my claim that “it is not true "
"that ``2 + 2 = 5``” then you would say that my claim is true, because "
"actually my claim is that “``2 + 2 = 5`` is false”. And I’m right. If we "
"write this in jamovi we use this:"
msgstr ""
"Til slutt har vi *not*-operatoren, som er enkel, men irriterende å beskrive "
"på engelsk. Hvis jeg ber deg vurdere min påstand om at «det er ikke sant at "
"``2 + 2 = 5``», så vil du si at påstanden min er sann, fordi påstanden min "
"egentlig er at «``2 + 2 = 5`` er usann». Og jeg har rett i det. Hvis vi "
"skriver dette i jamovi bruker vi dette:"

#: ../../Ch06/Ch06_DataHandling_2.rst:164
msgid ""
"In other words, since ``2 + 2 == 5`` is a ``FALSE`` statement, it must be "
"the case that ``NOT(2 + 2 == 5)`` is a ``TRUE`` one. Essentially, what we’ve "
"really done is claim that “not false” is the same thing as “true”. "
"Obviously, this isn’t really quite right in real life. But jamovi lives in a "
"much more black or white world. For jamovi everything is either ``TRUE`` or "
"``FALSE``. No shades of grey are allowed."
msgstr ""
"Med andre ord, siden ``2 + 2 == 5`` er en påstand som er ``FALSE``, må det "
"være slik at ``NOT(2 + 2 == 5)`` er en påstand som er ``TRUE``. Det vi "
"egentlig har gjort, er å hevde at «ikke usant» er det samme som «sant». "
"Dette er selvsagt ikke helt riktig i det virkelige liv. Men jamovi lever i "
"en mye mer svart-hvitt-verden. For jamovi er alt enten ``TRUE`` eller "
"``FALSE``. Ingen gråtoner er tillatt."

#: ../../Ch06/Ch06_DataHandling_2.rst:171
msgid ""
"Of course, in our ``2 + 2 = 5`` example, we didn’t really need to use the "
"“not” operator ``NOT`` and the “equals to” operator ``==`` as two separate "
"operators. We could have just used the “not equals to” operator ``!=`` like "
"this:"
msgstr ""
"I vårt eksempel ``2 + 2 = 5`` trengte vi selvfølgelig ikke å bruke «ikke»-"
"operatoren ``NOT`` og «er lik»-operatoren ``==`` som to separate operatorer. "
"Vi kunne bare ha brukt «ikke lik»-operatoren ``!=`` på denne måten:"

#: ../../Ch06/Ch06_DataHandling_2.rst:181
msgid "Applying logical operation to text"
msgstr "Bruke logiske operasjoner på tekst"

#: ../../Ch06/Ch06_DataHandling_2.rst:183
msgid ""
"I also want to briefly point out that you can apply these logical operators "
"to text as well as to logical data. It’s just that we need to be a bit more "
"careful in understanding how jamovi interprets the different operations. In "
"this section I’ll talk about how the equal to operator ``==`` applies to "
"text, since this is the most important one. Obviously, the not equal to "
"operator ``!=`` gives the exact opposite answers to ``==`` so I’m implicitly "
"talking about that one too, but I won’t give specific commands showing the "
"use of ``!=``."
msgstr ""
"Jeg vil også kort påpeke at du kan bruke disse logiske operatorene på tekst "
"så vel som på logiske data. Det er bare det at vi må være litt mer nøye med "
"å forstå hvordan jamovi tolker de ulike operasjonene. I dette avsnittet skal "
"jeg snakke om hvordan operatoren lik ``==`` brukes på tekst, siden dette er "
"den viktigste. Operatoren ``!=`` gir selvsagt det stikk motsatte svaret av "
"``==``, så jeg snakker implisitt om den også, men jeg kommer ikke til å gi "
"spesifikke kommandoer som viser bruken av ``!=``."

#: ../../Ch06/Ch06_DataHandling_2.rst:192
msgid ""
"Okay, let’s see how it works. In one sense, it’s very simple. For instance, "
"I can ask jamovi if the word ``cat`` is the same as the word ``dog``, like "
"this:"
msgstr ""
"Ok, la oss se hvordan det fungerer. På én måte er det veldig enkelt. Jeg kan "
"for eksempel spørre jamovi om ordet ``cat`` er det samme som ordet ``dog``, "
"slik:"

#: ../../Ch06/Ch06_DataHandling_2.rst:200
msgid ""
"That’s pretty obvious, and it’s good to know that even jamovi can figure "
"that out. Similarly, jamovi does recognise that a ``cat`` is a ``cat``:"
msgstr ""
"Det er ganske åpenbart, og det er godt å vite at til og med jamovi kan finne "
"ut av det. På samme måte skjønner jamovi at en ``cat`` er en ``cat``:"

#: ../../Ch06/Ch06_DataHandling_2.rst:207
msgid ""
"Again, that’s exactly what we’d expect. However, what you need to keep in "
"mind is that jamovi is not at all tolerant when it comes to grammar and "
"spacing. If two strings differ in any way whatsoever, jamovi will say that "
"they’re not equal to each other, as with the following:"
msgstr ""
"Igjen, det er akkurat det vi forventer. Det du imidlertid må huske på, er at "
"jamovi overhodet ikke er tolerant når det gjelder grammatikk og mellomrom. "
"Hvis to strenger skiller seg fra hverandre på noen som helst måte, vil "
"jamovi si at de ikke er like, slik som i følgende tilfelle:"

#: ../../Ch06/Ch06_DataHandling_2.rst:218
msgid ""
"You can also use other logical operators too. For instance jamovi also "
"allows you to use the ``<`` and ``>`` operators to determine which of two "
"text “strings” comes first, alphabetically speaking. Sort of. Actually, it’s "
"a bit more complicated than that, but let’s start with a simple example:"
msgstr ""
"Du kan også bruke andre logiske operatorer. For eksempel lar jamovi deg også "
"bruke operatorene ``<`` og ``>`` til å bestemme hvilken av to tekststrenger "
"som kommer først, alfabetisk sett. På en måte. Egentlig er det litt mer "
"komplisert enn som så, men la oss starte med et enkelt eksempel:"

#: ../../Ch06/Ch06_DataHandling_2.rst:228
msgid ""
"In jamovi, this example evaluates to ``TRUE``. This is because ``cat`` does "
"does come before ``dog`` alphabetically, so jamovi judges the statement to "
"be true. However, if we ask jamovi to tell us if ``cat`` comes before "
"``anteater`` then it will evaluate the expression as ``FALSE``. So far, so "
"good. But text data is a bit more complicated than the dictionary suggests. "
"What about ``cat`` and ``CAT``? Which of these comes first? Try it and find "
"out:"
msgstr ""
"I jamovi evalueres dette eksempelet til ``TRUE``. Dette er fordi ``cat`` "
"kommer før ``dog`` i alfabetet, så jamovi vurderer utsagnet til å være sant. "
"Hvis vi derimot ber jamovi om å vurdere om ``cat`` kommer før ``anteater``, "
"vil påstanden blir evaluert som ``FALSE``. Så langt, så bra. Men tekstdata "
"er litt mer komplisert enn ordboken antyder. Hva med ``cat`` og ``CAT``? "
"Hvilken av disse kommer først? Prøv det og finn ut av det:"

#: ../../Ch06/Ch06_DataHandling_2.rst:240
msgid ""
"This in fact evaluates to ``TRUE``. In other words, jamovi assumes that "
"uppercase letters come before lowercase ones. Fair enough. No-one is likely "
"to be surprised by that. What you might find surprising is that jamovi "
"assumes that *all* uppercase letters come before *all* lowercase ones. That "
"is, while ``\"anteater\" < \"zebra\"`` is a true statement, and the "
"uppercase equivalent ``\"ANTEATER\" < \"ZEBRA\"`` is also true, it is *not* "
"true to say that ``\"anteater\" < \"ZEBRA\"``, as the following extract "
"illustrates. Try this:"
msgstr ""
"Dette evalueres faktisk til ``TRUE``. Med andre ord antar jamovi at store "
"bokstaver kommer før små. Det er greit nok. Det er det neppe noen som blir "
"overrasket over. Det som kanskje overrasker deg, er at jamovi antar at "
"*alle* store bokstaver kommer før *alle* små bokstaver. Det vil si at selv "
"om ``\"anteater\" < \"zebra\"`` er et sant utsagn, og den tilsvarende store "
"bokstaven ``\"ANTEATER\" < \"ZEBRA\"`` også er sann, er det *ikke* sant å si "
"at ``\"anteater\" < \"ZEBRA\"``, som det følgende utdraget illustrerer. Prøv "
"dette:"

#: ../../Ch06/Ch06_DataHandling_2.rst:253
msgid ""
"This evaluates to ``FALSE``, and this may seem slightly counterintuitive. "
"With that in mind, it may help to have a quick look at the various text "
"characters in the order that jamovi processes them:"
msgstr ""
"Dette evalueres til ``FALSE``, og det kan virke litt kontraintuitivt. Med "
"det i bakhodet kan det hjelpe å ta en rask titt på de ulike teksttegnene i "
"den rekkefølgen jamovi behandler dem:"

#: ../../Ch06/Ch06_DataHandling_2.rst:266
msgid ""
"I offer up my teenage attempts to be “cool” as evidence that some things "
"just can’t be done."
msgstr ""
"Jeg bruker mine tenåringsforsøk på å være «kul» som bevis på at noen ting "
"bare ikke kan gjøres."

#: ../../Ch06/Ch06_DataHandling_2.rst:270
msgid ""
"You can do this in the Compute new variable screen, though just calculating "
"``2 + 2`` for every cell of a new variable is not very useful!"
msgstr ""
"Du kan gjøre dette i skjermbildet Compute new variable, selv om det ikke er "
"særlig nyttig å bare beregne ``2 + 2`` for hver celle i en ny variabel!"

#: ../../Ch06/Ch06_DataHandling_2.rst:275
msgid ""
"Note that this is a very different operator to the equals operator ``=``. A "
"common typo that people make when trying to write logical commands in jamovi "
"(or other languages, since the “``=`` versus ``==``” distinction is "
"important in many computer and statistical programs) is to accidentally type "
"``=`` when you really mean ``==``. Be especially cautious with this, I’ve "
"been programming in various languages since I was a teenager and I *still* "
"screw this up a lot. Hmm. I think I see why I wasn’t cool as a teenager. And "
"why I’m still not cool."
msgstr ""
"Merk at dette er en helt annen operator enn likhetsoperatoren ``=``. En "
"vanlig skrivefeil som folk gjør når de prøver å skrive logiske kommandoer i "
"jamovi (eller andre språk, siden skillet mellom ``=`` og ``==`` er viktig i "
"mange data- og statistikkprogrammer), er å skrive ``=`` når du egentlig "
"mener ``==``. Vær spesielt forsiktig med dette, jeg har programmert i "
"forskjellige språk siden jeg var tenåring, og jeg *fortsetter* å gjøre mange "
"feil. Hmm. Jeg tror jeg skjønner hvorfor jeg ikke var kul som tenåring. Og "
"hvorfor jeg fortsatt ikke er kul."

#: ../../Ch06/Ch06_DataHandling_2.rst:286
msgid ""
"Now, here’s a quirk in jamovi. When you have simple logical expressions like "
"the ones we have already met, e.g. ``2 + 2 == 5`` then jamovi neatly states "
"``FALSE`` (or ``TRUE``) in the corresponding spreadsheet column. Underneath "
"the hood, jamovi stores ``FALSE`` as ``0`` and ``TRUE`` as ``1``. When we "
"have more complex logical expressions, such as ``(2 + 2 == 4) or (2 + 2 == "
"5)``, then jamovi just displays either ``0`` or ``1``, depending whether the "
"logical expression is evaluated as false, or true."
msgstr ""
"Her er en finurlighet i jamovi. Når du har enkle logiske uttrykk som de vi "
"allerede har møtt, f.eks. ``2 + 2 == 5``, så skriver jamovi pent og pyntelig "
"``FALSE`` (eller ``TRUE``) i den tilsvarende kolonnen i regnearket. Under "
"panseret lagrer jamovi ``FALSE`` som ``0`` og ``TRUE`` som ``1``. Når vi har "
"mer komplekse logiske uttrykk, for eksempel ``(2 + 2 == 4) or (2 + 2 == "
"5)``, viser jamovi bare enten ``0`` eller ``1``, avhengig av om det logiske "
"uttrykket er evaluert som usant eller sant."

#: ../../Ch06/Ch06_DataHandling_3.rst:4
msgid "Transforming and recoding a variable"
msgstr "Transformering og omkoding av en variabel"

#: ../../Ch06/Ch06_DataHandling_3.rst:6
msgid ""
"It’s not uncommon in real world data analysis to find that one of your "
"variables isn’t quite equivalent to the variable that you really want. For "
"instance, it’s often convenient to take a continuous variable |continuous| "
"(e.g., age) and break it up into a smallish number of categories (e.g., "
"younger, middle, older). At other times, you may need to convert a numeric "
"variable into a different numeric variable (e.g., you may want to analyse at "
"the absolute value of the original variable). In this section I’ll describe "
"a few key ways you can do these things in jamovi."
msgstr ""
"Det er ikke uvanlig at man i dataanalyser finner ut at en av variablene ikke "
"er helt ekvivalent med den variabelen man egentlig ønsker. For eksempel er "
"det ofte praktisk å ta en kontinuerlig variabel |continuous| (f.eks. alder) "
"og dele den opp i et lite antall kategorier (f.eks. yngre, middels, eldre). "
"Andre ganger kan det være nødvendig å konvertere en numerisk variabel til en "
"annen numerisk variabel (f.eks. hvis du ønsker å analysere den absolutte "
"verdien av den opprinnelige variabelen). I dette avsnittet skal jeg beskrive "
"noen viktige måter du kan gjøre disse tingene på i jamovi."

#: ../../Ch06/Ch06_DataHandling_3.rst:298
msgid "continuous"
msgstr "continuous"

#: ../../Ch06/Ch06_DataHandling_3.rst:16
msgid "Creating a transformed variable"
msgstr "Opprette en transformert variabel"

#: ../../Ch06/Ch06_DataHandling_3.rst:18
msgid ""
"The first trick to discuss is the idea of **transforming** a variable. Taken "
"literally, *anything* you do to a variable is a transformation, but in "
"practice what it usually means is that you apply a relatively simple "
"mathematical function to the original variable in order to create a new "
"variable that either (a) provides a better way of describing the thing "
"you’re actually interested in, or (b) is more closely in agreement with the "
"assumptions of the statistical tests you want to do. Since, at this stage, I "
"haven’t talked about statistical tests or their assumptions, I’ll show you "
"an example based on the first case."
msgstr ""
"Det første trikset vi skal diskutere, er ideen om å **transformere** en "
"variabel. Bokstavelig talt er *alt* du gjør med en variabel en "
"transformasjon, men i praksis betyr det vanligvis at du bruker en relativt "
"enkel matematisk funksjon på den opprinnelige variabelen for å lage en ny "
"variabel som enten (a) gir en bedre beskrivelse av det du faktisk er "
"interessert i, eller (b) stemmer bedre overens med forutsetningene for de "
"statistiske testene du ønsker å utføre. Siden jeg på dette stadiet ikke har "
"snakket om statistiske tester eller forutsetningene for dem, skal jeg vise "
"deg et eksempel basert på det første tilfellet."

#: ../../Ch06/Ch06_DataHandling_3.rst:28
msgid ""
"Suppose I’ve run a short study in which I ask 10 people a single question:"
msgstr ""
"Anta at jeg har gjennomført en kort studie der jeg stiller ti personer ett "
"enkelt spørsmål:"

#: ../../Ch06/Ch06_DataHandling_3.rst:31
msgid ""
"On a scale of 1 (strongly disagree) to 7 (strongly agree), to what extent do "
"you agree with the proposition that “Dinosaurs are awesome”?"
msgstr ""
"På en skala fra 1 (helt uenig) til 7 (helt enig), i hvilken grad er du enig "
"i påstanden om at «Dinosaurer er fantastiske»?"

#: ../../Ch06/Ch06_DataHandling_3.rst:35
msgid ""
"Now let’s load and look at the data. The |likert|_ data set contains a "
"single variable that contains raw Likert-scale responses for these 10 "
"people. However, if you think about it, this isn’t the best way to represent "
"these responses. Because of the fairly symmetric way that we set up the "
"response scale, there’s a sense in which the midpoint of the scale should "
"have been coded as 0 (no opinion), and the two endpoints should be **+3** "
"(strongly agree) and **-3** (strongly disagree). By recoding the data in "
"this way it’s a bit more reflective of how we really think about the "
"responses. The recoding here is pretty straightforward, we just subtract 4 "
"from the raw scores. In jamovi you can do this by computing a new variable: "
"click on the ``Compute`` button in the ``Data`` tab and you will see that a "
"new variable has been added to the spreadsheet. Let’s call this new variable "
"``likert.centred`` (go ahead and type that in) and then add the following in "
"the formula box, like in :numref:`fig-likertraw`: ``likert.raw - 4``"
msgstr ""
"La oss nå laste inn og se på dataene. Datasettet |likert|_ inneholder en "
"enkelt variabel som inneholder rå Likert-skala-svar for disse 10 personene. "
"Men hvis du tenker deg om, er ikke dette den beste måten å representere "
"disse svarene på. På grunn av den ganske symmetriske måten vi har satt opp "
"svarskalaen på, burde midtpunktet på skalaen ha vært kodet som 0 (ingen "
"mening), og de to endepunktene burde ha vært **+3** (helt enig) og **-3** "
"(helt uenig). Ved å omkode dataene på denne måten gjenspeiler det i større "
"grad hvordan vi egentlig tenker om svarene. Omkodingen her er ganske enkel, "
"vi trekker bare 4 fra råskårene. I jamovi kan du gjøre dette ved å beregne "
"en ny variabel: Klikk på ``Compute``-knappen i ``Data``-fanen, og du vil se "
"at en ny variabel har blitt lagt til i regnearket. La oss kalle denne nye "
"variabelen ``likert.centred`` (skriv det inn), og legg deretter til følgende "
"i formelboksen, som i :numref:`fig-likertraw`: ``likert.raw - 4``"

#: ../../Ch06/Ch06_DataHandling_3.rst:52 ../../Ch06/Ch06_DataHandling_3.rst:56
msgid "Creating a new computed variable in jamovi"
msgstr "Opprette en ny beregnet variabel i jamovi"

#: ../../Ch06/Ch06_DataHandling_3.rst:60
msgid ""
"One reason why it might be useful to have the data in this format is that "
"there are a lot of situations where you might prefer to analyse the "
"*strength* of the opinion separately from the *direction* of the opinion. We "
"can do two different transformations on this ``likert.centred`` variable in "
"order to distinguish between these two different concepts. First, to compute "
"an ``opinion.strength`` variable, we want to take the absolute value of the "
"centred data (using the ``ABS`` function).\\ [#]_ In jamovi, create another "
"new variable using the ``Compute`` button. Name the variable ``opinion."
"strength`` and this time click on the *f*\\ :sub:`x` button next to the "
"``Formula`` box. This shows the different ``Functions`` and ``Variables`` "
"that you can add to the ``Formula`` box, so double click on ``ABS`` and then "
"double click on ``likert.centred`` and you will see that the ``Formula`` box "
"is populated with ``ABS(likert.centred)`` and a new variable has been "
"created in the spreadsheet view, as in :numref:`fig-opinionstrength`:"
msgstr ""
"En grunn til at det kan være nyttig å ha dataene i dette formatet, er at det "
"finnes mange situasjoner der man kanskje foretrekker å analysere *styrken* i "
"oppfatningen separat fra *retningen* i oppfatningen. Vi kan gjøre to ulike "
"transformasjoner på denne ``likert.centred``-variabelen for å skille mellom "
"disse to ulike konseptene. For det første, for å beregne en ``opinion."
"strength``-variabel, vil vi ta absoluttverdien av de sentrerte dataene (ved "
"hjelp av ``ABS``-funksjonen).\\ [#]_ I jamovi oppretter du en ny variabel "
"ved hjelp av ``Compute``-knappen. Gi variabelen navnet ``opinion.strength``, "
"og klikk denne gangen på *f*\\ :sub:`x`-knappen ved siden av ``Formula``-"
"boksen. Dette viser de forskjellige funksjonene (``Functions``) og "
"variablene (``Variables``) som du kan legge til i ``Formula``-boksen, så "
"dobbeltklikk på ``ABS`` og dobbeltklikk deretter på ``likert.centred``, og "
"du vil se at ``Formula``-boksen er fylt ut med ``ABS(likert.centred)`` og en "
"ny variabel er opprettet i regnearkvisningen, som i :numref:`fig-"
"opinionstrength`:"

#: ../../Ch06/Ch06_DataHandling_3.rst:78
msgid "*f*\\ :sub:`x` button to select functions and variables"
msgstr "*f*\\ :sub:`x`-knapp for å velge funksjoner og variabler"

#: ../../Ch06/Ch06_DataHandling_3.rst:82
msgid "Using the *f*\\ :sub:`x` button to select functions and variables"
msgstr "Bruk *f*\\ :sub:`x`-knappen til å velge funksjoner og variabler"

#: ../../Ch06/Ch06_DataHandling_3.rst:86
msgid ""
"Second, to compute a variable that contains only the direction of the "
"opinion and ignores the strength, we want to calculate the “sign” of the "
"variable. In jamovi we can use the ``IF`` function to do this. Create "
"another new variable using the ``Compute`` button, name this one ``opinion."
"sign``, and then type the following into the function box:"
msgstr ""
"For det andre, for å beregne en variabel som bare inneholder retningen på "
"oppfatningen og ignorerer styrken, ønsker vi å beregne «fortegnet» på "
"variabelen. I jamovi kan vi bruke ``IF``-funksjonen til å gjøre dette. "
"Opprett en ny variabel ved hjelp av ``Compute``-knappen, gi den navnet "
"``opinion.sign``, og skriv deretter inn følgende i funksjonsboksen:"

#: ../../Ch06/Ch06_DataHandling_3.rst:96
msgid ""
"When done, you’ll see that all negative numbers from the ``likert.centred`` "
"variable are converted to **-1**, all positive numbers are converted to "
"**1** and zero stays as **0**, like so:"
msgstr ""
"Når du er ferdig, vil du se at alle negative tall fra variabelen ``likert."
"centred`` blir konvertert til **-1**, alle positive tall blir konvertert til "
"**1** og null forblir **0**, slik som dette:"

#: ../../Ch06/Ch06_DataHandling_3.rst:104
msgid ""
"Let’s break down what this ``IF`` command is doing. In jamovi there are "
"three parts to an ``IF`` statement, written as ``IF(expression, value, "
"else)``. The first part, ``expression`` can be a logical or mathematical "
"statement. In our example, we have specified ``likert.centred == 0``, which "
"is ``TRUE`` for values where ``likert.centred`` is zero. The next part, "
"``value``, is the new value where the expression in part one is ``TRUE``. In "
"our example, we have said that for all those values where ``likert.centred`` "
"is zero, keep them zero. In the next part, ``else``, we can enter another "
"logical or mathematical statement to be used if part one evaluates to "
"``FALSE``, i.e. where ``likert.centred`` is not zero. In our example we have "
"divided ``likert.centred`` by opinion.strength to give ``-1`` or ``+1`` "
"depending of the sign of the original value in ``likert.centred``.\\ [#]_"
msgstr ""
"La oss forklare hva denne ``IF``-kommandoen gjør. I jamovi er det tre deler "
"i en ``IF``-funksjon, skrevet som ``IF(expression, value, else)``. Den "
"første delen, ``expression``, kan være et logisk eller matematisk utsagn. I "
"vårt eksempel har vi spesifisert ``likert.centred == 0``, som er ``TRUE`` "
"for verdier der ``likert.centred`` er null. Den neste delen, ``value``, er "
"den nye verdien der uttrykket i første del er ``TRUE``. I vårt eksempel har "
"vi sagt at for alle de verdiene der ``likert.centred`` er null, skal de "
"holdes på null. I neste del, ``else``, kan vi skrive inn en annen logisk "
"eller matematisk setning som skal brukes hvis del én evalueres til "
"``FALSE``, dvs. der ``likert.centred`` ikke er null. I vårt eksempel har vi "
"dividert ``likert.centred`` med opinion.strength for å gi ``-1`` eller "
"``+1`` avhengig av fortegnet til den opprinnelige verdien i ``likert."
"centred``.\\ [#]_"

#: ../../Ch06/Ch06_DataHandling_3.rst:117
msgid ""
"And we’re done. We now have three shiny new variables, all of which are "
"useful transformations of the original ``likert.raw`` variable."
msgstr ""
"Og vi er ferdige. Vi har nå tre nye, skinnende variabler, som alle er "
"nyttige transformasjoner av den opprinnelige variabelen ``likert.raw``."

#: ../../Ch06/Ch06_DataHandling_3.rst:121
msgid ""
"Collapsing a variable into a smaller number of discrete levels or categories"
msgstr ""
"Sammenfatte en variabel i et mindre antall diskrete nivåer eller kategorier"

#: ../../Ch06/Ch06_DataHandling_3.rst:123
msgid ""
"One pragmatic task that comes up quite often is the problem of collapsing a "
"variable into a smaller number of discrete levels or categories. For "
"instance, suppose I’m interested in looking at the age distribution of "
"people at a social gathering:"
msgstr ""
"En pragmatisk oppgave som ofte dukker opp, er problemet med å redusere en "
"variabel til et mindre antall diskrete nivåer eller kategorier. Anta for "
"eksempel at jeg er interessert i å se på aldersfordelingen blant deltakerne "
"på en sosial sammenkomst:"

#: ../../Ch06/Ch06_DataHandling_3.rst:132
msgid ""
"In some situations it can be quite helpful to group these into a smallish "
"number of categories. For example, we could group the data into three broad "
"categories: young (0-20), adult (21-40) and older (41-60). This is a quite "
"coarse-grained classification, and the labels that I’ve attached only make "
"sense in the context of this data set (e.g., viewed more generally, a 42 "
"year old wouldn’t consider themselves as “older”). We can slice this "
"variable up quite easily using the jamovi ``IF`` function that we have "
"already used. This time we have to specify nested ``IF`` statements, meaning "
"simply that ``IF`` the first logical expression is ``TRUE``, insert a first "
"value, but ``IF`` a second logical expression is ``TRUE``, insert a second "
"value, but ``IF`` a third logical expression is ``TRUE``, then insert a "
"third value. This can be written as:"
msgstr ""
"I noen situasjoner kan det være nyttig å gruppere disse i et mindre antall "
"kategorier. Vi kan for eksempel gruppere dataene i tre brede kategorier: "
"unge (0-20), voksne (21-40) og eldre (41-60). Dette er en ganske grovkornet "
"klassifisering, og merkelappene jeg har brukt, gir bare mening i konteksten "
"av dette datasettet (f.eks. vil en 42-åring generelt sett ikke anse seg selv "
"som «eldre»). Vi kan dele opp denne variabelen ganske enkelt ved hjelp av "
"jamovi ``IF``-funksjonen som vi allerede har brukt. Denne gangen må vi "
"spesifisere nestede ``IF``-funksjoner, noe som ganske enkelt betyr at ``IF`` "
"det første logiske uttrykket er ``TRUE``, sett inn en første verdi, men "
"``IF`` et andre logisk uttrykk er ``TRUE``, sett inn en andre verdi, men "
"``IF`` et tredje logisk uttrykk er ``TRUE``, sett så inn en tredje verdi. "
"Dette kan skrives som:"

#: ../../Ch06/Ch06_DataHandling_3.rst:149
msgid ""
"Note that there are three left parentheses used during the nesting, so the "
"whole statement has to end with three right parentheses otherwise you will "
"get an error message. The jamovi screen shot for this data manipulation, "
"along with an accompanying frequency table, is shown in :numref:`fig-"
"agecats`:"
msgstr ""
"Merk at det brukes tre parenteser på venstre side under nestingen, så hele "
"formel må avsluttes med tre parenteser på høyre side, ellers vil du få en "
"feilmelding. jamovi-skjermbildet for denne manipulasjonen, sammen med en "
"tilhørende frekvenstabell, vises i :numref:`fig-agecats`:"

#: ../../Ch06/Ch06_DataHandling_3.rst:157
msgid "Using the ``IF`` function"
msgstr "Bruk av ``IF``-funksjonen"

#: ../../Ch06/Ch06_DataHandling_3.rst:161
msgid ""
"Collapsing a variable into a smaller number of discrete levels using the "
"jamovi ``IF`` function"
msgstr ""
"Kollaps av en variabel til et mindre antall diskrete nivåer ved hjelp av "
"``IF``-funksjonen i jamovi"

#: ../../Ch06/Ch06_DataHandling_3.rst:166
msgid ""
"It’s important to take the time to figure out whether or not the resulting "
"categories make any sense at all in terms of your research project. If they "
"don’t make any sense to you as meaningful categories, then any data analysis "
"that uses those categories is likely to be just as meaningless. More "
"generally, in practice I’ve noticed that people have a very strong desire to "
"carve their (continuous and messy) data into a few (discrete and simple) "
"categories, and then run analyses using the categorised data instead of the "
"original data.\\ [#]_ I wouldn’t go so far as to say that this is an "
"inherently bad idea, but it does have some fairly serious drawbacks at "
"times, so I would advise some caution if you are thinking about doing it."
msgstr ""
"Det er viktig å ta seg tid til å finne ut om de resulterende kategoriene i "
"det hele tatt gir mening i forhold til forskningsprosjektet ditt. Hvis de "
"ikke gir mening for deg som meningsfulle kategorier, er det sannsynlig at "
"enhver dataanalyse som bruker disse kategoriene, vil være like meningsløs. "
"Mer generelt har jeg i praksis lagt merke til at folk har et veldig sterkt "
"ønske om å dele opp (kontinuerlige og uoversiktlige) data i noen få "
"(diskrete og enkle) kategorier, og deretter kjøre analyser ved hjelp av de "
"kategoriserte dataene i stedet for de opprinnelige dataene.\\ [#]_ Jeg vil "
"ikke gå så langt som å si at dette er en dårlig idé i seg selv, men det har "
"til tider noen ganske alvorlige ulemper, så jeg vil råde til forsiktighet "
"hvis du vurderer å gjøre det."

#: ../../Ch06/Ch06_DataHandling_3.rst:179
msgid "Creating a transformation that can be applied to multiple variables"
msgstr "Opprette en transformasjon som kan brukes på flere variabler"

#: ../../Ch06/Ch06_DataHandling_3.rst:181
msgid ""
"Sometimes you want to apply the same transformation to more than one "
"variable, for example when you have multiple questionnaire items that all "
"need to be recalculated or recoded in the same way. And one of the neat "
"features in jamovi is that you can create a transformation, using the "
"``Transform`` button in the ``Data`` tab, that can then be saved and applied "
"to multiple variables. Let’s go back to the first example above, using the |"
"likert|_ data set that contains a single variable with raw Likert-scale "
"responses for 10 people. To create a transformation that you can save and "
"then apply across multiple variables (assuming you had more variables like "
"this in your data file), first in the spreadsheet editor select (i.e., "
"click) the variable you want to use to initially create the transformation. "
"In our example this is ``likert.raw``. Next click the ``Transform`` button "
"in the jamovi ``Data`` tab, and you’ll see something like :numref:`fig-"
"transform1`."
msgstr ""
"Noen ganger ønsker du å bruke samme transformasjon på mer enn én variabel, "
"for eksempel når du har flere spørreskjemaelementer som alle må beregnes på "
"nytt eller omkodes på samme måte. En av de smarte funksjonene i jamovi er at "
"du kan opprette en transformasjon ved hjelp av ``Transform``-knappen i "
"``Data``-fanen, som deretter kan lagres og brukes på flere variabler. La oss "
"gå tilbake til det første eksemplet ovenfor, med datasettet |likert|_, som "
"inneholder en enkelt variabel med rå Likert-skala-svar for 10 personer. For "
"å opprette en transformasjon som du kan lagre og deretter bruke på flere "
"variabler (forutsatt at du hadde flere slike variabler i datafilen), velger "
"(dvs. klikker) du først variabelen du vil bruke til å opprette "
"transformasjonen, i regnearkredigeringsprogrammet. I vårt eksempel er dette "
"``likert.raw``. Deretter klikker du på ``Transform``-knappen i jamovi "
"``Data``-fanen, og du vil se noe som :numref:`fig-transform1`."

#: ../../Ch06/Ch06_DataHandling_3.rst:198
msgid "Using the jamovi ``Transform`` command"
msgstr "Bruke ``Transform``-kommandoen i jamovi"

#: ../../Ch06/Ch06_DataHandling_3.rst:202
msgid ""
"Creating a new variable transformation using the jamovi ``Transform`` command"
msgstr ""
"Opprette en ny variabeltransformasjon ved hjelp av ``Transform``-kommandoen "
"i jamovi"

#: ../../Ch06/Ch06_DataHandling_3.rst:207
msgid ""
"Give your new variable a name, let’s call it ``opinion.strength`` and then "
"click on the ``Using transform`` selection box and select ``Create New "
"Transform…``. This is where you will create, and name, the transformation "
"that can be re-applied to as many variables as you like. The transformation "
"is automatically named for us as ``Transform 1`` (imaginative, huh. You can "
"change this if you like). Then type the expression ``ABS($source - 4)`` into "
"the function text box, as in :numref:`fig-transform2`, press Enter or Return "
"on your keyboard and, hey presto, you have created a new transformation and "
"applied it to the ``likert.raw`` variable! Good, eh. Note that instead of "
"using the variable label in the expression, we have instead used "
"``$source``. This is so that we can then use the same transformation with as "
"many different variables as we like - jamovi requires you to use ``$source`` "
"to refer to the source variable you are transforming. Your transformation "
"has also been saved and can be re-used any time you like (providing you save "
"the dataset as an ``.omv`` file, otherwise you’ll lose it!)."
msgstr ""
"Gi den nye variabelen et navn, la oss kalle den ``opinion.strength``, og "
"klikk deretter på valgboksen ``Using transform``, og velg ``Create New "
"Transform…``. Her oppretter og navngir du transformasjonen som kan brukes på "
"så mange variabler du vil. Transformasjonen får automatisk navnet "
"``Transform 1`` (fantasifullt, ikke sant? Du kan endre dette hvis du vil). "
"Skriv deretter inn uttrykket ``ABS($source - 4)`` i funksjonstekstboksen, "
"som i :numref:`fig-transform2`, trykk Enter eller Return på tastaturet, og "
"vips, så har du opprettet en ny transformasjon og brukt den på variabelen "
"``likert.raw``! Bra, ikke sant? Legg merke til at vi i stedet for å bruke "
"variabelnavn i uttrykket har brukt ``$source``. Dette er for at vi skal "
"kunne bruke den samme transformasjonen på så mange forskjellige variabler "
"som vi vil - jamovi krever at du bruker ``$source`` for å referere til "
"kildevariabelen du transformerer. Transformasjonen din er også lagret og kan "
"brukes på nytt når du vil (forutsatt at du lagrer datasettet som en ``.omv``-"
"fil, ellers mister du det!)."

#: ../../Ch06/Ch06_DataHandling_3.rst:226
msgid "Specifying a transformation in jamovi"
msgstr "Spesifisere en transformasjon i jamovi"

#: ../../Ch06/Ch06_DataHandling_3.rst:230
msgid ""
"Specifying a transformation in jamovi, to be saved as the imaginatively "
"named ``Transform 1``"
msgstr ""
"Spesifiserer en transformasjon i jamovi, som skal lagres som den "
"fantasifullt navngitte ``Transform 1``"

#: ../../Ch06/Ch06_DataHandling_3.rst:235
msgid ""
"You can also create a transformation with the second example we looked at, "
"the age distribution of people at a social gathering. Go on, you know you "
"want to! Remember that we collapsed this variable into three groups: "
"younger, adult and older. This time we will achieve the same thing, but "
"using the jamovi ``Transform`` → ``Add condition`` button. With this data "
"set (go back to it or create it again if you didn’t save it) set up a new "
"variable transformation. Call the transformed variable ``AgeCats`` and the "
"transformation you will create ``Agegroupings``. Then click on the big ``+`` "
"sign next to the function box. This is the ``Add condition`` button and I’ve "
"stuck a big red arrow onto :numref:`fig-transform3` so you can see exactly "
"where this is. Re-create the transformation shown in :numref:`fig-"
"transform3` and when you have done, you will see the new values appear in "
"the spreadsheet window. What’s more, the ``Agegroupings`` transformation has "
"been saved and can be re-applied any time you like. Ok, so I know that it’s "
"unlikely you will have more than one ``Age`` variable, but you get the idea "
"now of how to set up transformations in jamovi, so you can follow this idea "
"with other sorts of variables. A typical scenario for this is when you have "
"a questionnaire scale with, say, 20 items (variables) and each item was "
"originally scored from 1 to 6 but, for some reason or quirk of the data you "
"decide to recode all the items as 1 to 3. You can easily do this in jamovi "
"by creating and then re-applying your transformation for each variable that "
"you want to recode."
msgstr ""
"Du kan også lage en transformasjon med det andre eksempelet vi så på, nemlig "
"aldersfordelingen på en sosial sammenkomst. Kom igjen, du vet at du har lyst "
"til det! Husk at vi delte denne variabelen inn i tre grupper: yngre, voksne "
"og eldre. Denne gangen vil vi oppnå det samme, men ved å bruke jamovi "
"``Transform`` → ``Add condition``-knappen. Med dette datasettet (gå tilbake "
"til det eller opprett det på nytt hvis du ikke har lagret det) setter du opp "
"en ny variabeltransformasjon. Kall den transformerte variabelen ``AgeCats`` "
"og transformasjonen du vil opprette ``Agegroupings``. Klikk deretter på det "
"store tegnet ``+`` ved siden av funksjonsboksen. Dette er knappen ``Add "
"condition``, og jeg har satt en stor rød pil på :numref:`fig-transform3` "
"slik at du kan se nøyaktig hvor denne er. Gjenopprett transformasjonen som "
"vises i :numref:`fig-transform3`, og når du har gjort det, vil du se de nye "
"verdiene vises i regnearkvinduet. Dessuten er ``Agegroupings``-"
"transformasjonen lagret og kan brukes på nytt når du vil. Ok, jeg vet at det "
"er lite sannsynlig at du vil ha mer enn én ``Age``-variabel, men nå har du "
"fått ideen om hvordan du kan sette opp transformasjoner i jamovi, så du kan "
"følge denne ideen med andre typer variabler. Et typisk scenario for dette er "
"når du har en spørreskjemaskala med for eksempel 20 elementer (variabler), "
"og hvert element opprinnelig ble skåret fra 1 til 6, men av en eller annen "
"grunn eller på grunn av dataenes særegenhet bestemmer du deg for å omkode "
"alle elementene til 1 til 3. Du kan enkelt gjøre dette i jamovi ved å "
"opprette og deretter bruke transformasjonen på nytt for hver variabel som du "
"vil omkode."

#: ../../Ch06/Ch06_DataHandling_3.rst:259
msgid "jamovi transformation into categories"
msgstr "jamovi transformasjon til kategorier"

#: ../../Ch06/Ch06_DataHandling_3.rst:263
msgid ""
"jamovi transformation into three age categories, using the ``Add condition`` "
"button"
msgstr ""
"jamovi-transformasjon i tre alderskategorier, ved hjelp av knappen ``Add "
"condition``"

#: ../../Ch06/Ch06_DataHandling_3.rst:271
msgid ""
"The absolute value of a number is its distance from zero, regardless of "
"whether it’s sign is negative or positive."
msgstr ""
"Den absolutte verdien av et tall er dets avstand fra null, uavhengig av om "
"det har negativt eller positivt fortegn."

#: ../../Ch06/Ch06_DataHandling_3.rst:275
msgid ""
"The reason we have to use the ``IF`` command and keep zero as zero is that "
"you cannot just use ``likert.centred / opinion.strength`` to calculate the "
"sign of ``likert.centred``, because mathematically dividing zero by zero "
"does not work. Try it and see."
msgstr ""
"Grunnen til at vi må bruke ``IF``-kommandoen og beholde null som null, er at "
"du ikke bare kan bruke ``likert.centred / opinion.strength`` for å beregne "
"fortegnet til ``likert.centred``, fordi det matematisk sett ikke fungerer å "
"dele null med null. Prøv det og se."

#: ../../Ch06/Ch06_DataHandling_3.rst:281
msgid ""
"If you’ve read further into the book, and are re-reading this section, then "
"a good example of this would be someone choosing to do an ANOVA using "
"``AgeCats`` as the grouping variable, instead of running a regression using "
"``Age`` as a predictor. There are sometimes good reasons for doing this. For "
"instance, if the relationship between ``Age`` and your outcome variable is "
"highly non-linear and you aren’t comfortable with trying to run non-linear "
"regression! However, unless you really do have a good rationale for doing "
"this, it’s best not to. It tends to introduce all sorts of other problems (e."
"g., the data will probably violate the normality assumption) and you can "
"lose a lot of statistical power."
msgstr ""
"Hvis du har lest videre i boken og leser denne delen på nytt, kan et godt "
"eksempel på dette være at noen velger å gjøre en ANOVA med ``AgeCats`` som "
"grupperingsvariabel, i stedet for å kjøre en regresjon med ``Age`` som "
"prediktor. Noen ganger er det gode grunner til å gjøre dette. For eksempel "
"hvis forholdet mellom ``Age`` og utfallsvariabelen din er svært ikke-"
"lineært, og du ikke er komfortabel med å prøve å kjøre ikke-lineær "
"regresjon! Men med mindre du virkelig har en god begrunnelse for å gjøre "
"dette, er det best å la være. Det har en tendens til å introdusere alle "
"mulige andre problemer (f.eks. vil dataene sannsynligvis bryte med "
"forutsetningen om normalfordeling), og du kan miste mye statistisk styrke."

#: ../../Ch06/Ch06_DataHandling_4.rst:4
msgid "Mathematical functions and operations"
msgstr "Matematiske funksjoner og operasjoner"

#: ../../Ch06/Ch06_DataHandling_4.rst:6
msgid ""
"In the previous section, I discussed the ideas behind variable "
"transformations and showed that a lot of the transformations that you might "
"want to apply to your data are based on fairly simple mathematical functions "
"and operations. In this section I want to return to that discussion and "
"mention several other mathematical functions and arithmetic operations that "
"are actually quite useful for a lot of real world data analysis. :numref:"
"`tab-mathfunc` gives a brief overview of the various mathematical functions "
"I want to talk about here, or later.\\ [#]_ Obviously this doesn’t even come "
"close to cataloguing the range of possibilities available, but it does cover "
"a range of functions that are used regularly in data analysis and that are "
"available in jamovi."
msgstr ""
"I forrige avsnitt diskuterte jeg ideene bak variabeltransformasjoner og "
"viste at mange av de transformasjonene du kanskje vil bruke på dataene dine, "
"er basert på ganske enkle matematiske funksjoner og operasjoner. I dette "
"avsnittet vil jeg gå tilbake til denne diskusjonen og nevne flere andre "
"matematiske funksjoner og regneoperasjoner som faktisk er ganske nyttige for "
"mange dataanalyser. :numref:`tab-mathfunc` gir en kort oversikt over de "
"ulike matematiske funksjonene jeg vil snakke om her, eller senere.\\ [#]_ "
"Dette er selvsagt langt fra en fullstendig oversikt over alle mulighetene "
"som finnes. Men det dekker en rekke funksjoner som brukes regelmessig i "
"dataanalyse, og som er tilgjengelige i jamovi."

#: ../../Ch06/Ch06_DataHandling_4.rst:17
msgid "Some of the mathematical functions available in jamovi"
msgstr "Noen av de matematiske funksjonene som er tilgjengelige i jamovi"

#: ../../Ch06/Ch06_DataHandling_4.rst:21
msgid "Function"
msgstr "Funksjon"

#: ../../Ch06/Ch06_DataHandling_4.rst:21
msgid "Example input"
msgstr "Eksempel på input"

#: ../../Ch06/Ch06_DataHandling_4.rst:21
msgid "result"
msgstr "resultat"

#: ../../Ch06/Ch06_DataHandling_4.rst:23
msgid "Square root"
msgstr "Kvadratrot"

#: ../../Ch06/Ch06_DataHandling_4.rst:23
msgid "``SQRT(x)``"
msgstr "``SQRT(x)``"

#: ../../Ch06/Ch06_DataHandling_4.rst:23
msgid "``SQRT(25)``"
msgstr "``SQRT(25)``"

#: ../../Ch06/Ch06_DataHandling_4.rst:23
msgid "5"
msgstr "5"

#: ../../Ch06/Ch06_DataHandling_4.rst:25
msgid "Absolute value"
msgstr "Absolutt verdi"

#: ../../Ch06/Ch06_DataHandling_4.rst:25
msgid "``ABS(x)``"
msgstr "``ABS(x)``"

#: ../../Ch06/Ch06_DataHandling_4.rst:25
msgid "``ABS(-23)``"
msgstr "``ABS(-23)``"

#: ../../Ch06/Ch06_DataHandling_4.rst:25
msgid "23"
msgstr "23"

#: ../../Ch06/Ch06_DataHandling_4.rst:27
msgid "Logarithm (base 10)"
msgstr "Logaritme (med base 10)"

#: ../../Ch06/Ch06_DataHandling_4.rst:27
msgid "``LOG10(x)``"
msgstr "``LOG10(x)``"

#: ../../Ch06/Ch06_DataHandling_4.rst:27
msgid "``LOG10(1000)``"
msgstr "``LOG10(1000)``"

#: ../../Ch06/Ch06_DataHandling_4.rst:27
msgid "3"
msgstr "3"

#: ../../Ch06/Ch06_DataHandling_4.rst:30
msgid "Logarithm (base *e*)"
msgstr "Logaritme (med base *e*)"

#: ../../Ch06/Ch06_DataHandling_4.rst:30
msgid "``LN(x)``"
msgstr "``LN(x)``"

#: ../../Ch06/Ch06_DataHandling_4.rst:30
msgid "``LN(1000)``"
msgstr "``LN(1000)``"

#: ../../Ch06/Ch06_DataHandling_4.rst:30
msgid "6.908"
msgstr "6.908"

#: ../../Ch06/Ch06_DataHandling_4.rst:33
msgid "Exponentiation"
msgstr "Eksponentiering"

#: ../../Ch06/Ch06_DataHandling_4.rst:33
msgid "``EXP(x)``"
msgstr "``EXP(x)``"

#: ../../Ch06/Ch06_DataHandling_4.rst:33
msgid "``EXP(6.908)``"
msgstr "``EXP(6.908)``"

#: ../../Ch06/Ch06_DataHandling_4.rst:33
msgid "1000.245"
msgstr "1000.245"

#: ../../Ch06/Ch06_DataHandling_4.rst:35
msgid "Box-Cox"
msgstr "Box-Cox"

#: ../../Ch06/Ch06_DataHandling_4.rst:35
msgid "``BOXCOX(x, lamda)``"
msgstr "``BOXCOX(x, lamda)``"

#: ../../Ch06/Ch06_DataHandling_4.rst:35
msgid "``BOXCOX(6.908, 3)``"
msgstr "``BOXCOX(6.908, 3)``"

#: ../../Ch06/Ch06_DataHandling_4.rst:35
msgid "109.551"
msgstr "109.551"

#: ../../Ch06/Ch06_DataHandling_4.rst:37
msgid "Rounding to nearest"
msgstr "Avrunding til nærmeste heltall"

#: ../../Ch06/Ch06_DataHandling_4.rst:37
msgid "``ROUND()``"
msgstr "``ROUND()``"

#: ../../Ch06/Ch06_DataHandling_4.rst:37
msgid "``ROUND(1.32)``"
msgstr "``ROUND(1.32)``"

#: ../../Ch06/Ch06_DataHandling_4.rst:37 ../../Ch06/Ch06_DataHandling_4.rst:40
msgid "1"
msgstr "1"

#: ../../Ch06/Ch06_DataHandling_4.rst:40
msgid "Rounding down"
msgstr "Avrunding nedover"

#: ../../Ch06/Ch06_DataHandling_4.rst:40
msgid "``FLOOR()``"
msgstr "``FLOOR()``"

#: ../../Ch06/Ch06_DataHandling_4.rst:40
msgid "``FLOOR(1.32)``"
msgstr "``FLOOR(1.32)``"

#: ../../Ch06/Ch06_DataHandling_4.rst:42
msgid "Rounding up"
msgstr "Avrunding oppover"

#: ../../Ch06/Ch06_DataHandling_4.rst:42
msgid "``CEILING()``"
msgstr "``CEILING()``"

#: ../../Ch06/Ch06_DataHandling_4.rst:42
msgid "``CEILING(1.32)``"
msgstr "``CEILING(1.32)``"

#: ../../Ch06/Ch06_DataHandling_4.rst:42
msgid "2"
msgstr "2"

#: ../../Ch06/Ch06_DataHandling_4.rst:47
msgid "Logarithms and exponentials"
msgstr "Logaritmer og eksponentialer"

#: ../../Ch06/Ch06_DataHandling_4.rst:49
msgid ""
"As I’ve mentioned earlier, jamovi has an useful range of mathematical "
"functions built into it and there really wouldn’t be much point in trying to "
"describe or even list all of them. For the most part, I’ve focused only on "
"those functions that are strictly necessary for this book. However I do want "
"to make an exception for logarithms and exponentials. Although they aren’t "
"needed anywhere else in this book, they are *everywhere* in statistics more "
"broadly. And not only that, there are a *lot* of situations in which it is "
"convenient to analyse the logarithm of a variable (i.e., to take a “log-"
"transform” of the variable). I suspect that many (maybe most) readers of "
"this book will have encountered logarithms and exponentials before, but from "
"past experience I know that there’s a substantial proportion of students who "
"take a social science statistics class who haven’t touched logarithms since "
"high school, and would appreciate a bit of a refresher."
msgstr ""
"Som jeg har nevnt tidligere, har jamovi en rekke nyttige matematiske "
"funksjoner innebygd, og det ville ikke være noen vits i å prøve å beskrive "
"eller liste opp dem alle. Jeg har stort sett bare fokusert på de funksjonene "
"som er strengt nødvendige for denne boken. Jeg vil imidlertid gjøre et "
"unntak for logaritmer og eksponentialer. Selv om de ikke er nødvendige noe "
"annet sted i denne boken, er de *overalt* i statistikk mer generelt. Og ikke "
"bare det, det finnes *mange* situasjoner der det er praktisk å analysere "
"logaritmen til en variabel (dvs. å ta en «log-transformasjon» av "
"variabelen). Jeg regner med at mange (kanskje de fleste) lesere av denne "
"boken har støtt på logaritmer og eksponentialer før, men av erfaring vet jeg "
"at det er en betydelig andel av studentene som tar samfunnsvitenskapelig "
"statistikk, som ikke har vært borti logaritmer siden videregående skole, og "
"som ville sette pris på en liten oppfriskning."

#: ../../Ch06/Ch06_DataHandling_4.rst:64
msgid ""
"In order to understand logarithms and exponentials, the easiest thing to do "
"is to actually calculate them and see how they relate to other simple "
"calculations. There are three jamovi functions in particular that I want to "
"talk about, namely ``LN()``, ``LOG10()`` and ``EXP()``. To start with, let’s "
"consider ``LOG10()``, which is known as the “logarithm in base 10”. The "
"trick to understanding a **logarithm** is to understand that it’s basically "
"the “opposite” of taking a power. Specifically, the logarithm in base 10 is "
"closely related to the powers of 10. So let’s start by noting that 10-cubed "
"is 1000. Mathematically, we would write this:"
msgstr ""
"For å forstå logaritmer og eksponentialer er det enklest å faktisk beregne "
"dem og se hvordan de henger sammen med andre enkle utregninger. Det er "
"spesielt tre jamovi-funksjoner jeg vil snakke om, nemlig ``LN()``, "
"``LOG10()`` og ``EXP()``. La oss begynne med ``LOG10()``, som er kjent som "
"«logaritmen med base 10». Trikset med å forstå en **logaritme** er å forstå "
"at det i utgangspunktet er det «motsatte» av å ta en potens. Logaritmen med "
"base 10 er nært knyttet til potenser av 10. Så la oss begynne med å merke "
"oss at 10-kubikk er 1000. Matematisk sett ville vi skrevet dette:"

#: ../../Ch06/Ch06_DataHandling_4.rst:75
msgid "10³ = 1000"
msgstr "10³ = 1000"

#: ../../Ch06/Ch06_DataHandling_4.rst:77
msgid ""
"The trick to understanding a logarithm is to recognise that the statement "
"that “10 to the power of 3 is equal to 1000” is equivalent to the statement "
"that “the logarithm (in base 10) of 1000 is equal to 3”. Mathematically, we "
"write this as follows,"
msgstr ""
"Trikset for å forstå en logaritme er å innse at utsagnet «10 i potensen 3 er "
"lik 1000» tilsvarer utsagnet «logaritmen (med base 10) til 1000 er lik 3». "
"Matematisk skriver vi dette på følgende måte,"

#: ../../Ch06/Ch06_DataHandling_4.rst:82
msgid "log\\ :sub:`10`\\(1000) = 3"
msgstr "log\\ :sub:`10`\\(1000) = 3"

#: ../../Ch06/Ch06_DataHandling_4.rst:84
msgid ""
"Okay, since the ``LOG10()`` function is related to the powers of 10, you "
"might expect that there are other logarithms (in bases other than 10) that "
"are related to other powers too. And of course that’s true: there’s not "
"really anything mathematically special about the number 10. You and I happen "
"to find it useful because decimal numbers are built around the number 10, "
"but the big bad world of mathematics scoffs at our decimal numbers. Sadly, "
"the universe doesn’t actually care how we write down numbers. Anyway, the "
"consequence of this cosmic indifference is that there’s nothing particularly "
"special about calculating logarithms in base 10. You could, for instance, "
"calculate your logarithms in base 2. Alternatively, a third type of "
"logarithm, and one we see a lot more of in statistics than either base 10 or "
"base 2, is called the **natural logarithm**, and corresponds to the "
"logarithm in base *e*. Since you might one day run into it, I’d better "
"explain what *e* is. The number *e*, known as **Euler’s number**, is one of "
"those annoying “irrational” numbers whose decimal expansion is infinitely "
"long, and is considered one of the most important numbers in mathematics. "
"The first few digits of *e* are:"
msgstr ""
"Siden ``LOG10()``-funksjonen er relatert til potenser av 10, forventer du "
"kanskje at det finnes andre logaritmer (med andre baser enn 10) som også er "
"relatert til andre potenser. Og det er selvfølgelig sant: Det er egentlig "
"ikke noe matematisk spesielt med tallet 10. Du og jeg synes tilfeldigvis at "
"det er nyttig fordi desimaltall er bygget opp rundt tallet 10, men den "
"store, stygge matematiske verden håner desimaltallene våre. Dessverre bryr "
"universet seg faktisk ikke om hvordan vi skriver ned tall. Konsekvensen av "
"denne kosmiske likegyldigheten er uansett at det ikke er noe spesielt med å "
"beregne logaritmer med base 10. Du kan for eksempel regne logaritmer med "
"base 2. Alternativt finnes det en tredje type logaritme, som vi ser mye mer "
"av i statistikken enn både base 10 og base 2. Den kalles **naturlig "
"logaritme**, og tilsvarer logaritmen med base *e*. Siden du kanskje støter "
"på den en dag, er det best å forklare hva *e* er. Tallet *e*, kjent som "
"**Eulers tall**, er et av de irriterende «irrasjonale» tallene som har "
"uendelig lang desimalutvidelse, og regnes som et av de viktigste tallene i "
"matematikken. De første sifrene i *e* er:"

#: ../../Ch06/Ch06_DataHandling_4.rst:102
msgid "*e* = 2.718282"
msgstr "*e* = 2.718282"

#: ../../Ch06/Ch06_DataHandling_4.rst:104
msgid ""
"There are quite a few situation in statistics that require us to calculate "
"powers of *e*, though none of them appear in this book. Raising *e* to the "
"power *x* is called the **exponential** of *x*, and so it’s very common to "
"see e\\ :sup:`x` written as *exp(x)*. And so it’s no surprise that jamovi "
"has a function that calculates exponentials, called ``EXP()``. Because the "
"number *e* crops up so often in statistics, the natural logarithm (i.e., "
"logarithm in base *e*) also tends to turn up. Mathematicians often write it "
"as log\\ :sub:`e`\\ (x) or *ln(x)*. In fact, jamovi works the same way: the "
"``LN()`` function corresponds to the natural logarithm."
msgstr ""
"Det finnes en del situasjoner i statistikk som krever at vi beregner "
"potenser av *e*, men ingen av dem dukker opp i denne boken. Å opphøye *e* "
"til potensen *x* kalles **eksponentialen** av *x*, og det er derfor veldig "
"vanlig å se e\\ :sup:`x` skrevet som *exp(x)*. Det er derfor ikke "
"overraskende at jamovi har en funksjon som beregner eksponentialer, kalt "
"``EXP()``. Fordi tallet *e* dukker opp så ofte i statistikken, har også den "
"naturlige logaritmen (dvs. logaritmen med basen *e*) en tendens til å dukke "
"opp. Matematikere skriver den ofte som log\\ :sub:`e`\\(x) eller *ln(x)*. "
"Faktisk fungerer jamovi på samme måte: funksjonen ``LN()`` tilsvarer den "
"naturlige logaritmen."

#: ../../Ch06/Ch06_DataHandling_4.rst:115
msgid ""
"And with that, I think we’ve had quite enough exponentials and logarithms "
"for this book!"
msgstr ""
"Og med det tror jeg vi har fått nok eksponentialer og logaritmer for denne "
"boken!"

#: ../../Ch06/Ch06_DataHandling_4.rst:121
msgid "We’ll leave the box-cox function until :ref:`later on <box-cox>`."
msgstr ""
"Vi venter med å bruke box-cox-funksjonen til :ref:`senere på <box-cox>`."

#: ../../Ch06/Ch06_DataHandling_5.rst:4
msgid "Extracting a subset of the data"
msgstr "Trekker ut en delmengde av dataene"

#: ../../Ch06/Ch06_DataHandling_5.rst:6
msgid ""
"One very important kind of data handling is being able to extract a "
"particular subset of the data. For instance, you might be interested only in "
"analysing the data from one experimental condition, or you may want to look "
"closely at the data from people over 50 years in age. To do this, the first "
"step is getting jamovi to filter the subset of the data corresponding to the "
"observations that you’re interested in."
msgstr ""
"En svært viktig type datahåndtering er å kunne trekke ut en bestemt "
"delmengde av dataene. Det kan for eksempel være at du bare er interessert i "
"å analysere data fra én eksperimentell betingelse, eller at du ønsker å se "
"nærmere på data fra personer over 50 år. For å gjøre dette må du først få "
"jamovi til å filtrere delmengden av data som tilsvarer de observasjonene du "
"er interessert i."

#: ../../Ch06/Ch06_DataHandling_5.rst:13
msgid ""
"This section returns to the |nightgarden|_ data set. If you’re reading this "
"whole chapter in one sitting, then you should already have this data set "
"loaded into a jamovi window. For this section, let’s focus on the two "
"variables ``speaker`` and ``utterance`` (see :doc:`Ch06_DataHandling_1` if "
"you’ve forgotten what those variables look like). Suppose that what I want "
"to do is pull out only those utterances that were made by ``makka-pakka``. "
"To that end, we need to specify a filter in jamovi. First open up a filter "
"window by clicking on ``Filters`` on the main jamovi ``Data`` toolbar. Then, "
"in the ``Filter 1`` text box, next to the ``=`` sign, type the following:"
msgstr ""
"I dette avsnittet vender vi tilbake til datasettet |nightgarden|_. Hvis du "
"leser hele dette kapittelet i én omgang, bør du allerede ha lastet dette "
"datasettet inn i et jamovi-vindu. I dette avsnittet skal vi fokusere på de "
"to variablene ``speaker`` og ``utterance`` (se :doc:`Ch06_DataHandling_1` "
"hvis du har glemt hvordan disse variablene ser ut). Anta at det jeg ønsker å "
"gjøre, er å trekke ut bare de ytringene som ble fremsatt av ``makka-pakka``. "
"For å gjøre det må vi spesifisere et filter i jamovi. Først åpner du et "
"filtervindu ved å klikke på ``Filters`` på jamovis ``Data``-verktøylinje. "
"Deretter skriver du inn følgende i tekstboksen ``Filter 1``, ved siden av "
"tegnet ``=``:"

#: ../../Ch06/Ch06_DataHandling_5.rst:27
msgid ""
"When you have done this, you will see that a new column has been added to "
"the spreadsheet window (see :numref:`fig-subset1`), labelled ``Filter 1``, "
"with the cases where ``speaker`` is not ``makka-pakka`` greyed-out (i.e., "
"filtered out) and, conversely, the cases where ``speaker`` is ``makka-"
"pakka`` have a green check mark indicating they are filtered in. You can "
"test this by running ``Exploration`` → ``Descriptives``, assigning "
"``speaker`` to the ``Variables``- box and checking ``Frequency tables``. Go "
"on, try it, and see what that shows!"
msgstr ""
"Når du har gjort dette, vil du se at en ny kolonne med navn ``Filter 1`` er "
"lagt til i regnearkvinduet (se :numref:`fig-subset1`), hvor tilfellene der "
"``speaker`` ikke er ``makka-pakka`` er gråtonet (dvs. filtrert ut), og "
"omvendt, har tilfellene der ``speaker`` er ``makka-pakka`` en grønn hake som "
"indikerer at de er inkludert. Du kan teste dette ved å utføre "
"``Exploration`` → ``Descriptives``, tilordne ``speaker`` til ``Variables``-"
"boksen og krysse av for ``Frequency tables``. Prøv det, og se hva det viser!"

#: ../../Ch06/Ch06_DataHandling_5.rst:37
msgid "Creating a subset using ``Filters``"
msgstr "Opprette en delmengde ved hjelp av ``Filters``"

#: ../../Ch06/Ch06_DataHandling_5.rst:41
msgid ""
"Creating a subset of the |nightgarden|_ data set using the jamovi "
"``Filters`` option"
msgstr ""
"Opprette en delmengde av datasettet |nightgarden|_ ved hjelp av jamovi "
"``Filters``-funksjon"

#: ../../Ch06/Ch06_DataHandling_5.rst:46
msgid ""
"Following on from this simple example, you can also build up more complex "
"filters using logical expressions in jamovi. For instance, suppose I wanted "
"to keep only those cases when the utterance is either ``pip`` or ``oo``. In "
"this case in the ``Filter 1`` text box, next to the ``=`` sign, you would "
"type the following:"
msgstr ""
"I forlengelsen av dette enkle eksempelet kan du også bygge opp mer komplekse "
"filtre ved hjelp av logiske uttrykk i jamovi. Tenk deg for eksempel at jeg "
"bare vil beholde de tilfellene der ytringen er enten ``pip`` eller ``oo``. I "
"så fall ville du i tekstboksen ``Filter 1``, ved:"
