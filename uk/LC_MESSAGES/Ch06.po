msgid ""
msgstr ""
"Project-Id-Version: PROJECT VERSION\n"
"Report-Msgid-Bugs-To: sebastian.jentschke@uib.no\n"
"POT-Creation-Date: 2025-06-12 11:37+0200\n"
"PO-Revision-Date: 2025-09-02 08:02+0000\n"
"Last-Translator: Максим Горпиніч <gorpinicmaksim0@gmail.com>\n"
"Language-Team: Ukrainian <https://hosted.weblate.org/projects/lsjdocs/ch06/"
"uk/>\n"
"Language: uk\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"X-Generator: Weblate 5.13.1-dev\n"
"Generated-By: Babel 2.15.0\n"

#: ../../Ch06/Ch06_DataHandling.rst:4
msgid "Pragmatic matters"
msgstr "Прагматичні питання"

#: ../../Ch06/Ch06_DataHandling.rst:20
msgid ""
"*The garden of life never seems to confine itself to the plots philosophers "
"have laid out for its convenience. Maybe a few more tractors would do the "
"trick.*"
msgstr ""
"*Сад життя, здається, ніколи не обмежується ділянками, які філософи "
"розпланували для його зручності. Можливо, ще кілька тракторів вистачило б.*"

#: ../../Ch06/Ch06_DataHandling.rst:24
msgid "Roger Zelazny (Home is the Hangman, 1975)"
msgstr "Роджер Желязни (Дім — це кат, 1975)"

#: ../../Ch06/Ch06_DataHandling.rst:27
msgid ""
"This is a somewhat strange chapter, even by my standards. My goal in this "
"chapter is to talk a bit more honestly about the realities of working with "
"data than you’ll see anywhere else in the book. The problem with real world "
"data sets is that they are *messy*. Very often the data file that you start "
"out with doesn’t have the variables stored in the right format for the "
"analysis you want to do. Sometimes there might be a lot of missing values in "
"your data set. Sometimes you only want to analyse a subset of the data. Et "
"cetera. In other words, there’s a lot of **data manipulation** that you need "
"to do just to get the variables in your data set into the format that you "
"need it. The purpose of this chapter is to provide a basic introduction to "
"these pragmatic topics. Although the chapter is motivated by the kinds of "
"practical issues that arise when manipulating real data, I’ll stick with the "
"practice that I’ve adopted through most of the book and rely on very small, "
"toy data sets that illustrate the underlying issue. Because this chapter is "
"essentially a collection of techniques and doesn’t tell a single coherent "
"story, it may be useful to start with a list of topics:"
msgstr ""
"Це дещо дивна глава, навіть за моїми мірками. Моя мета в цій главі — трохи "
"чесніше розповісти про реалії роботи з даними, ніж ви побачите в будь-якій "
"іншій частині книги. Проблема з наборами даних у реальному світі полягає в "
"тому, що вони *безладні*. Дуже часто файл даних, з якого ви починаєте, не "
"містить змінних, збережених у форматі, придатному для аналізу, який ви "
"хочете провести. Іноді у вашому наборі даних може бути багато відсутніх "
"значень. Іноді ви хочете проаналізувати лише підмножину даних. І так далі. "
"Іншими словами, вам доведеться виконати багато **операцій з даними**, щоб "
"перетворити змінні у вашому наборі даних у потрібний вам формат. Мета цього "
"розділу — надати базове введення в ці практичні теми. Хоча цей розділ "
"мотивований практичними проблемами, що виникають під час маніпулювання "
"реальними даними, я дотримуватимуся практики, яку я застосовував у більшій "
"частині книги, і покладатимуся на дуже малі, іграшкові набори даних, що "
"ілюструють основну проблему. Оскільки цей розділ є, по суті, збіркою технік "
"і не розповідає єдиної послідовної історії, може бути корисно почати зі "
"списку тем:"

#: ../../Ch06/Ch06_DataHandling.rst:45
msgid ":doc:`Ch06_DataHandling_1`"
msgstr ":doc:`Ch06_DataHandling_1`"

#: ../../Ch06/Ch06_DataHandling.rst:47
msgid ":doc:`Ch06_DataHandling_2`"
msgstr ":doc:`Ch06_DataHandling_2`"

#: ../../Ch06/Ch06_DataHandling.rst:49
msgid ":doc:`Ch06_DataHandling_3`"
msgstr ":doc:`Ch06_DataHandling_3`"

#: ../../Ch06/Ch06_DataHandling.rst:51
msgid ":doc:`Ch06_DataHandling_4`"
msgstr ":doc:`Ch06_DataHandling_4`"

#: ../../Ch06/Ch06_DataHandling.rst:53
msgid ":doc:`Ch06_DataHandling_5`"
msgstr ":doc:`Ch06_DataHandling_5`"

#: ../../Ch06/Ch06_DataHandling.rst:55
msgid ""
"As you can see, the list of topics that the chapter covers is pretty broad, "
"and there’s a *lot* of content there. Even though this is one of the longest "
"and hardest chapters in the book, I’m really only scratching the surface of "
"several fairly different and important topics. My advice, as usual, is to "
"read through the chapter once and try to follow as much of it as you can. "
"Don’t worry too much if you can’t grasp it all at once, especially the later "
"sections. The rest of the book is only lightly reliant on this chapter so "
"you can get away with just understanding the basics. However, what you’ll "
"probably find is that later on you’ll need to flick back to this chapter in "
"order to understand some of the concepts that I refer to here."
msgstr ""
"Як бачите, перелік тем, які охоплює ця глава, є досить широким, і там є "
"*багато* змісту. Хоча це одна з найдовших і найскладніших глав у книзі, я "
"лише поверхнево торкаюся кількох досить різних і важливих тем. Моя порада, "
"як завжди, — прочитати главу один раз і спробувати зрозуміти якомога більше. "
"Не переймайтеся, якщо не зможете одразу все зрозуміти, особливо в останніх "
"розділах. Решта книги лише частково спирається на цей розділ, тож ви можете "
"обійтися лише розумінням основ. Однак, ймовірно, ви зрозумієте, що пізніше "
"вам доведеться повернутися до цього розділу, щоб зрозуміти деякі поняття, на "
"які я тут посилаюся."

#: ../../Ch06/Ch06_DataHandling_1.rst:4
msgid "Tabulating and cross-tabulating data"
msgstr "Табулювання та перехресне табулювання даних"

#: ../../Ch06/Ch06_DataHandling_1.rst:6
msgid ""
"A very common task when analysing data is the construction of frequency "
"tables, or cross-tabulation of one variable against another. These tasks can "
"be achieved in jamovi and I’ll show you how in this section."
msgstr ""
"Дуже поширеним завданням при аналізі даних є побудова таблиць частот або "
"перехресна табуляція однієї змінної відносно іншої. Ці завдання можна "
"виконати в jamovi, і в цьому розділі я покажу вам, як це зробити."

#: ../../Ch06/Ch06_DataHandling_1.rst:11
msgid "Creating tables for single variables"
msgstr "Створення таблиць для окремих змінних"

#: ../../Ch06/Ch06_DataHandling_1.rst:13
msgid ""
"Let’s start with a simple example. As a parent of a small child I naturally "
"spend a lot of time watching TV shows like *In the Night Garden*. In the |"
"nightgarden|_ data set, I’ve transcribed a short section of the dialogue. "
"The file contains two variables of interest, ``speaker`` and ``utterance``. "
"Open up this data set in jamovi and take a look at the data in the ``Data`` "
"view. You will see that the data looks something like this:"
msgstr ""
"Почнемо з простого прикладу. Як батько маленької дитини, я, природно, "
"проводжу багато часу, дивлячись телевізійні програми, такі як *In the Night "
"Garden*. У наборі даних |nightgarden|_ я переписав невеликий фрагмент "
"діалогу. Файл містить дві цікаві змінні: ``speaker`` і ``utterance``. "
"Відкрийте цей набір даних у jamovi і подивіться на дані у вікні ``Data``. Ви "
"побачите, що дані виглядають приблизно так:"

#: ../../Ch06/Ch06_DataHandling_1.rst:20
msgid "``speaker`` variable"
msgstr "Змінна ``speaker``"

#: ../../Ch06/Ch06_DataHandling_1.rst:26
msgid "``utterance`` variable"
msgstr "Змінна ``utterance``"

#: ../../Ch06/Ch06_DataHandling_1.rst:33
msgid ""
"Looking at this it becomes very clear what happened to my sanity! With these "
"as my data, one task I might find myself needing to do is construct a "
"frequency count of the number of words each character speaks during the "
"show. The jamovi ``Descriptives`` screen has a check box called ``Frequency "
"tables`` which does just this, see :numref:`fig-freqtable`."
msgstr ""
"Дивлячись на це, стає дуже зрозуміло, що сталося з моїм розумом! Маючи ці "
"дані, одне із завдань, яке мені, можливо, доведеться виконати, — це скласти "
"таблицю частотності слів, які кожен персонаж вимовляє протягом серіалу. На "
"екрані jamovi ``Descriptives`` є прапорець ``Frequency tables``, який саме "
"це і робить, див. :numref:`fig-freqtable`."

#: ../../Ch06/Ch06_DataHandling_1.rst:41 ../../Ch06/Ch06_DataHandling_1.rst:45
msgid "Frequency table for the ``speaker`` variable"
msgstr "Таблиця частот для змінної ``speaker``"

#: ../../Ch06/Ch06_DataHandling_1.rst:49
msgid ""
"The output here tells us on the first line that what we’re looking at is a "
"tabulation of the ``speaker`` variable. In the ``Levels`` column it lists "
"all the different speakers that exist in the data, and in the ``Counts`` "
"column it tells you how many times that speaker appears in the data. In "
"other words, it’s a frequency table."
msgstr ""
"У першому рядку результату ми бачимо, що перед нами таблиця змінної "
"``speaker``. У стовпці ``Levels`` перелічені всі різні мовці, які є в даних, "
"а в стовпці ``Counts`` вказано, скільки разів цей мовець з'являється в "
"даних. Іншими словами, це таблиця частотності."

#: ../../Ch06/Ch06_DataHandling_1.rst:55
msgid ""
"In jamovi, the ``Frequency tables`` check box will only produce a table for "
"single variables. For a table of two variables, for example combining "
"``speaker`` and ``utterance`` so that we can see how many times each speaker "
"said a particular utterance, we need a cross-tabulation or contingency "
"table. In jamovi you can do this by selecting the ``Frequencies`` → "
"``Contingency Tables`` → ``Independent Samples`` analysis, and moving the "
"``speaker`` variable into the ``Rows`` box, and the ``utterance`` variable "
"into the ``Columns`` box. You then should have a contingency table like the "
"one shown in :numref:`fig-contingencytable`."
msgstr ""
"У jamovi прапорець ``Таблиці частот`` створює таблицю тільки для одиночних "
"змінних. Для таблиці з двома змінними, наприклад, поєднання ``оратор`` і "
"``висловлювання``, щоб ми могли побачити, скільки разів кожен оратор вимовив "
"певне висловлювання, нам потрібна перехресна таблиця або таблиця "
"співвідношень. У jamovi це можна зробити, вибравши аналіз ``Частоти`` → ``"
"Таблиці співвідношень`` → ``Незалежні вибірки`` і перемістивши змінну "
"``оратор`` у поле ``Рядки``, а змінну ``висловлювання`` — у поле ``Стовпці``"
". Після цього ви отримаєте таблицю співвідношень, як показано на :numref"
":`fig-contingencytable`."

#: ../../Ch06/Ch06_DataHandling_1.rst:67
msgid "Contingency table for ``speaker`` and ``utterance``"
msgstr "Таблиця непередбачених обставин для ``speaker`` і ``utterance``"

#: ../../Ch06/Ch06_DataHandling_1.rst:71
msgid "Contingency table for the ``speaker`` and ``utterance`` variables"
msgstr "Таблиця спряженості для змінних ``speaker`` та ``utterance``"

#: ../../Ch06/Ch06_DataHandling_1.rst:75
msgid ""
"Don’t worry about the ``χ² Tests`` table that is produced. We are going to "
"cover this later on in chapter :doc:`../Ch10/Ch10_ChiSquare`. When "
"interpreting the contingency table remember that these are counts, so the "
"fact that the first row and second column of numbers corresponds to a value "
"of 2 indicates that ``makka-pakka`` (row 1) says ``onk`` (column 2) twice in "
"this data set."
msgstr ""
"Не турбуйтеся про таблицю ``χ² Tests``, яка буде сформована. Ми розглянемо "
"це пізніше в розділі :doc:`../Ch10/Ch10_ChiSquare`. Інтерпретуючи таблицю "
"співвідношень, пам'ятайте, що це підрахунки, тому той факт, що перший рядок "
"і другий стовпець чисел відповідають значенню 2, означає, що ``makka-pakka`` "
"(рядок 1) двічі повторюється в ``onk`` (стовпець 2) у цьому наборі даних."

#: ../../Ch06/Ch06_DataHandling_1.rst:82
msgid "Adding percentages to a contingency table"
msgstr "Додавання відсотків до таблиці спряженості"

#: ../../Ch06/Ch06_DataHandling_1.rst:84
msgid ""
"The contingency table shown in :numref:`fig-contingencytable` shows a table "
"of raw frequencies. That is, a count of the total number of cases for "
"different combinations of levels of the specified variables. However, often "
"you want your data to be organised in terms of percentages as well as "
"counts. You can find the check boxes for different percentages under the "
"``Cells`` option in the ``Contingency Tables`` window. First, click on the "
"``Row`` check box and the Contingency Table in the output window will change "
"to the one in :numref:`fig-contingencyrow`."
msgstr ""
"Таблиця співвідношень, показана в :numref:`fig-contingencytable`, відображає "
"таблицю необроблених частот. Тобто, підрахунок загальної кількості випадків "
"для різних комбінацій рівнів зазначених змінних. Однак часто ви хочете, щоб "
"ваші дані були організовані як у відсотках, так і в кількості. Ви можете "
"знайти прапорці для різних відсотків в опції ``Cells`` у вікні ``Contingency "
"Tables``. Спочатку натисніть на прапорець ``Row``, і таблиця співвідношень у "
"вікні виводу зміниться на таку, як у :numref:`fig-contingencyrow`."

#: ../../Ch06/Ch06_DataHandling_1.rst:95
msgid ""
"Contingency table with row percentages for ``speaker`` and ``utterance``"
msgstr ""
"Таблиця непередбачених обставин з відсотками в рядках для ``speaker`` і "
"``utterance``"

#: ../../Ch06/Ch06_DataHandling_1.rst:99
msgid ""
"Contingency table for the ``speaker`` and ``utterance`` variables, with row "
"percentages"
msgstr ""
"Таблиця зв'язків для змінних ``speaker`` та ``utterance`` з відсотками рядків"

#: ../../Ch06/Ch06_DataHandling_1.rst:104
msgid ""
"What we’re looking at here is the percentage of utterances made by each "
"character. In other words, 50\\% of ``makka-pakka``’s utterances are "
"``pip``, and the other 50\\% are ``onk``. Let’s contrast this with the table "
"we get when we calculate column percentages (uncheck ``Row`` and check "
"``Column`` in the ``Cells`` options window), see :numref:`fig-"
"contingencycol`. In this version, what we’re seeing is the percentage of "
"characters associated with each utterance. For instance, whenever the "
"utterance ``ee`` is made (in this data set), 100\\% of the time it’s a "
"Tombliboo saying it."
msgstr ""
"Тут ми бачимо відсоток висловлювань кожного персонажа. Іншими словами, 50 % "
"висловлювань ``makka-pakka`` — це ``pip``, а інші 50 % — ``onk``. Порівняймо "
"це з таблицею, яку ми отримуємо, коли обчислюємо відсотки стовпців (зніміть "
"галочку ``Row`` і поставте галочку ``Column`` у вікні опцій ``Cells``), див. "
":numref:`fig-contingencycol`. У цій версії ми бачимо відсоток персонажів, "
"пов'язаних з кожним висловлюванням. Наприклад, коли висловлювання ``ee`` (у "
"цьому наборі даних) робиться, 100 % випадків це говорить Tombliboo."

#: ../../Ch06/Ch06_DataHandling_1.rst:115
msgid ""
"Contingency table with column percentages for ``speaker`` and ``utterance``"
msgstr ""
"Таблиця спряженості з відсотками у стовпцях для ``speaker`` та ``utterance``"

#: ../../Ch06/Ch06_DataHandling_1.rst:119
msgid ""
"Contingency table for the ``speaker`` and ``utterance`` variables, with "
"column percentages"
msgstr ""
"Таблиця зв'язків для змінних ``speaker`` та ``utterance`` з відсотками у "
"стовпцях"

#: ../../Ch06/Ch06_DataHandling_2.rst:4
msgid "Logical expressions in jamovi"
msgstr "Логічні вирази в jamovi"

#: ../../Ch06/Ch06_DataHandling_2.rst:6
msgid ""
"A key concept that a lot of data transformations in jamovi rely on is the "
"idea of a **logical value**. A logical value is an assertion about whether "
"something is true or false. This is implemented in jamovi in a pretty "
"straightforward way. There are two logical values, namely ``TRUE`` and "
"``FALSE``. Despite the simplicity, logical values are very useful things. "
"Let’s see how they work."
msgstr ""
"Ключовим поняттям, на якому базується багато перетворень даних у jamovi, є "
"ідея **логічного значення**. Логічне значення — це твердження про те, чи є "
"щось істинним чи хибним. У jamovi це реалізовано досить простим способом. "
"Існує два логічних значення, а саме ``TRUE`` та ``FALSE``. Незважаючи на "
"простоту, логічні значення є дуже корисними. Давайте подивимося, як вони "
"працюють."

#: ../../Ch06/Ch06_DataHandling_2.rst:14
msgid "Assessing mathematical truths"
msgstr "Оцінювання математичних істин"

#: ../../Ch06/Ch06_DataHandling_2.rst:16
msgid ""
"In George Orwell’s classic book *1984* one of the slogans used by the "
"totalitarian Party was “two plus two equals five”. The idea being that the "
"political domination of human freedom becomes complete when it is possible "
"to subvert even the most basic of truths. It’s a terrifying thought, "
"especially when the protagonist Winston Smith finally breaks down under "
"torture and agrees to the proposition. “Man is infinitely malleable”, the "
"book says. I’m pretty sure that this isn’t true of humans\\ [#]_ and it’s "
"definitely not true of jamovi. jamovi is not infinitely malleable, it has "
"rather firm opinions on the topic of what is and isn’t true, at least as "
"regards basic mathematics. If I ask it to calculate ``2 + 2``,\\ [#]_ it "
"always gives the same answer, and it’s not bloody 5!"
msgstr ""
"У класичній книзі Джорджа Орвелла *1984* одним із гасел, які використовувала "
"тоталітарна партія, було «два плюс два дорівнює п'ять». Ідея полягала в "
"тому, що політичне панування над свободою людини стає повним, коли можна "
"підірвати навіть найосновніші істини. Це жахлива думка, особливо коли "
"головний герой Вінстон Сміт нарешті ламається під тортурами і погоджується з "
"цією тезою. «Людина нескінченно пластична», — йдеться в книзі. Я впевнений, "
"що це неправда щодо людей\\ [#]_ і це точно неправда щодо jamovi. jamovi не "
"є нескінченно пластичним, він має досить тверді думки щодо того, що є "
"правдою, а що ні, принаймні стосовно базової математики. Якщо я попрошу його "
"обчислити ``2 + 2``,\\ [#]_ він завжди дасть однакову відповідь, і це не "
"буде кляте 5!"

#: ../../Ch06/Ch06_DataHandling_2.rst:29
msgid ""
"Of course, so far jamovi is just doing the calculations. I haven’t asked it "
"to explicitly assert that ``2 + 2 = 4`` is a true statement. If I want "
"jamovi to make an explicit judgement, I can use a command like this: ``2 + 2 "
"== 4``"
msgstr ""
"Звичайно, поки що jamovi лише виконує обчислення. Я не просив його чітко "
"стверджувати, що ``2 + 2 = 4`` є істинним твердженням. Якщо я хочу, щоб "
"jamovi виніс чітке судження, я можу використати таку команду: ``2 + 2 == 4``"

#: ../../Ch06/Ch06_DataHandling_2.rst:34
msgid ""
"What I’ve done here is use the **equality operator**, ``==``, to force "
"jamovi to make a “``TRUE`` or ``FALSE``” judgement.\\ [#]_ Okay, let’s see "
"what jamovi thinks of the Party slogan, so type this into the compute new "
"variable ``Formula`` box:"
msgstr ""
"Тут я використав **оператор рівності** ``==``, щоб змусити jamovi зробити "
"висновок «``TRUE`` або ``FALSE``». [#]_ Гаразд, давайте подивимося, що "
"jamovi думає про слоган партії, тому введіть це в поле обчислення нової "
"змінної ``Formula``:"

#: ../../Ch06/Ch06_DataHandling_2.rst:43
msgid ""
"And what do you get? It should be a whole set of ``FALSE`` values in the "
"spreadsheet column for your newly computed variable. Booyah! Freedom and "
"ponies for all! Or something like that. Anyway, it was worth having a look "
"at what happens if I try to *force* jamovi to believe that two plus two is "
"five by making a statement like ``2 + 2 = 5``. I know that if I do this in "
"another program, say ``R``, then it throws up an error message. But wait, if "
"you do this in jamovi you get a whole set of ``FALSE`` values. So what is "
"going on? Well, it seems that jamovi is being pretty smart and realises that "
"you are testing whether it is ``TRUE`` or ``FALSE`` that ``2 + 2 = 5``, "
"regardless of whether you use the correct **equality operator**, ``==``, or "
"the equals sign ``=``."
msgstr ""
"І що ви отримаєте? Це має бути цілий набір значень ``FALSE`` у стовпці "
"електронної таблиці для вашої новообчисленої змінної. Ура! Свобода і поні "
"для всіх! Або щось на зразок того. У будь-якому разі, варто було подивитися, "
"що станеться, якщо я спробую *примусити* jamovi повірити, що два плюс два "
"дорівнює п'ять, зробивши заяву на кшталт ``2 + 2 = 5``. Я знаю, що якщо я "
"зроблю це в іншій програмі, скажімо, ``R``, то вона видасть повідомлення про "
"помилку. Але зачекайте, якщо ви зробите це в jamovi, ви отримаєте цілий "
"набір значень ``FALSE``. То що ж відбувається? Схоже, jamovi досить розумний "
"і розуміє, що ви перевіряєте, чи ``TRUE`` або ``FALSE`` ``2 + 2 = 5``, "
"незалежно від того, чи використовуєте ви правильний **оператор рівності** "
"``==`` або знак рівності ``=``."

#: ../../Ch06/Ch06_DataHandling_2.rst:56
msgid "Logical operations"
msgstr "Логічні операції"

#: ../../Ch06/Ch06_DataHandling_2.rst:58
msgid ""
"So now we’ve seen logical operations at work. But so far we’ve only seen the "
"simplest possible example. You probably won’t be surprised to discover that "
"we can combine logical operations with other operations and functions in a "
"more complicated way, like this:"
msgstr ""
"Отже, ми побачили, як працюють логічні операції. Але поки що ми розглянули "
"лише найпростіший приклад. Вас, мабуть, не здивує, що логічні операції можна "
"поєднувати з іншими операціями та функціями у більш складному вигляді, "
"наприклад так:"

#: ../../Ch06/Ch06_DataHandling_2.rst:67
msgid "or this"
msgstr "або це"

#: ../../Ch06/Ch06_DataHandling_2.rst:73
msgid ""
"Not only that, but as :numref:`tab-logicals` illustrates, there are several "
"other logical operators that you can use corresponding to some basic "
"mathematical concepts. Hopefully these are all pretty self-explanatory. For "
"example, the **less than** operator ``<`` checks to see if the number on the "
"left is less than the number on the right. If it’s less, then jamovi returns "
"an answer of ``TRUE``, but if the two numbers are equal, or if the one on "
"the right is larger, then jamovi returns an answer of ``FALSE``."
msgstr ""
"Не тільки це, але, як показує :numref:`tab-logicals`, існує кілька інших "
"логічних операторів, які ви можете використовувати відповідно до деяких "
"основних математичних понять. Сподіваємося, що всі вони досить зрозумілі. "
"Наприклад, оператор **менше за** ``<`` перевіряє, чи число ліворуч менше за "
"число праворуч. Якщо воно менше, то jamovi повертає відповідь ``TRUE``, але "
"якщо два числа рівні або число праворуч більше, то jamovi повертає відповідь "
"``FALSE``."

#: ../../Ch06/Ch06_DataHandling_2.rst:81
msgid ""
"Some logical operators. Technically I should be calling these “binary "
"relational operators”, but quite frankly I don’t want to. It’s my book so no-"
"one can make me."
msgstr ""
"Деякі логічні оператори. Технічно я мав би називати їх «бінарними "
"реляційними операторами», але, чесно кажучи, я не хочу цього робити. Це моя "
"книга, тому ніхто не може мене змусити."

#: ../../Ch06/Ch06_DataHandling_2.rst:87 ../../Ch06/Ch06_DataHandling_2.rst:137
msgid "operation"
msgstr "операція"

#: ../../Ch06/Ch06_DataHandling_2.rst:87 ../../Ch06/Ch06_DataHandling_2.rst:137
msgid "operator"
msgstr "оператор"

#: ../../Ch06/Ch06_DataHandling_2.rst:87 ../../Ch06/Ch06_DataHandling_2.rst:137
msgid "example input"
msgstr "приклад введення"

#: ../../Ch06/Ch06_DataHandling_2.rst:87 ../../Ch06/Ch06_DataHandling_2.rst:137
msgid "answer"
msgstr "відповідь"

#: ../../Ch06/Ch06_DataHandling_2.rst:89
msgid "less than"
msgstr "менше ніж"

#: ../../Ch06/Ch06_DataHandling_2.rst:89
msgid "``<``"
msgstr "``<``"

#: ../../Ch06/Ch06_DataHandling_2.rst:89
msgid "``2 < 3``"
msgstr "``2 < 3``"

#: ../../Ch06/Ch06_DataHandling_2.rst:89 ../../Ch06/Ch06_DataHandling_2.rst:91
#: ../../Ch06/Ch06_DataHandling_2.rst:95 ../../Ch06/Ch06_DataHandling_2.rst:99
#: ../../Ch06/Ch06_DataHandling_2.rst:141
msgid "``TRUE``"
msgstr "``TRUE``"

#: ../../Ch06/Ch06_DataHandling_2.rst:91
msgid "less than or equal to"
msgstr "менше або дорівнює"

#: ../../Ch06/Ch06_DataHandling_2.rst:91
msgid "``<=``"
msgstr "``<=``"

#: ../../Ch06/Ch06_DataHandling_2.rst:91
msgid "``2 <= 2``"
msgstr "``2 <= 2``"

#: ../../Ch06/Ch06_DataHandling_2.rst:93
msgid "greater than"
msgstr "більше ніж"

#: ../../Ch06/Ch06_DataHandling_2.rst:93
msgid "``>``"
msgstr "``>``"

#: ../../Ch06/Ch06_DataHandling_2.rst:93
msgid "``2 > 3``"
msgstr "``2 > 3``"

#: ../../Ch06/Ch06_DataHandling_2.rst:93 ../../Ch06/Ch06_DataHandling_2.rst:97
#: ../../Ch06/Ch06_DataHandling_2.rst:139
#: ../../Ch06/Ch06_DataHandling_2.rst:143
msgid "``FALSE``"
msgstr "``FALSE``"

#: ../../Ch06/Ch06_DataHandling_2.rst:95
msgid "greater than or equal to"
msgstr "більше або дорівнює"

#: ../../Ch06/Ch06_DataHandling_2.rst:95
msgid "``>=``"
msgstr "``>=``"

#: ../../Ch06/Ch06_DataHandling_2.rst:95
msgid "``2 >= 2``"
msgstr "``2 >= 2``"

#: ../../Ch06/Ch06_DataHandling_2.rst:97
msgid "equal to"
msgstr "дорівнює"

#: ../../Ch06/Ch06_DataHandling_2.rst:97
msgid "``==``"
msgstr "``==``"

#: ../../Ch06/Ch06_DataHandling_2.rst:97
msgid "``2 == 3``"
msgstr "``2 == 3``"

#: ../../Ch06/Ch06_DataHandling_2.rst:99
msgid "not equal to"
msgstr "не дорівнює"

#: ../../Ch06/Ch06_DataHandling_2.rst:99
msgid "``!=``"
msgstr "``!=``"

#: ../../Ch06/Ch06_DataHandling_2.rst:99
msgid "``2 != 3``"
msgstr "``2 != 3``"

#: ../../Ch06/Ch06_DataHandling_2.rst:103
msgid ""
"In contrast, the **less than or equal to** operator ``<=`` will do exactly "
"what it says. It returns a value of ``TRUE`` if the number of the left hand "
"side is less than or equal to the number on the right hand side. At this "
"point I hope it’s pretty obvious what the **greater than** operator ``>`` "
"and the **greater than or equal to** operator ``>=`` do!"
msgstr ""
"На відміну від цього, оператор **менше або дорівнює** ``<=`` робить саме те, "
"що й означає його назва. Він повертає значення ``TRUE``, якщо число зліва "
"менше або дорівнює числу справа. На цьому етапі, сподіваюся, вже цілком "
"зрозуміло, що роблять оператор **більше, ніж** ``>`` та оператор **більше "
"або дорівнює** ``>=``!"

#: ../../Ch06/Ch06_DataHandling_2.rst:109
msgid ""
"Next on the list of logical operators is the **not equal to** operator ``!"
"=`` which, as with all the others, does what it says it does. It returns a "
"value of ``TRUE`` when things on either side are not identical to each "
"other. Therefore, since ``2 + 2`` isn’t equal to *5* we would get ``TRUE`` "
"as the value for our newly computed variable. Try it and see:"
msgstr ""
"Наступним у списку логічних операторів є оператор **не дорівнює** ``!=``, "
"який, як і всі інші, виконує те, що вказано в його назві. Він повертає "
"значення ``TRUE``, коли елементи по обидва боки не є ідентичними один "
"одному. Отже, оскільки ``2 + 2`` не дорівнює *5*, ми отримаємо ``TRUE`` як "
"значення для нашої новообчисленої змінної. Спробуйте і переконайтеся:"

#: ../../Ch06/Ch06_DataHandling_2.rst:119
msgid ""
"We’re not quite done yet. There are three more logical operations that are "
"worth knowing about, listed in :numref:`tab-logicals2`. These are the "
"**not** operator ``!``, the **and**-operator ``and``, and the **or**-"
"operator ``or``. Like the other logical operators, their behaviour is more "
"or less exactly what you’d expect given their names. For instance, if I ask "
"you to assess the claim that “either ``2 + 2 = 4`` *or* ``2 + 2 = 5``” you’d "
"say that it’s true. Since it’s an “either-or” statement, all we need is for "
"one of the two parts to be true. That’s what the ``or`` operator does:\\ [#]_"
msgstr ""
"Ми ще не закінчили. Є ще три логічні оператори, про які варто знати, вони "
"перелічені в :numref:`tab-logicals2`. Це оператор **не** ``!``, оператор "
"**і** ``and`` та оператор **або** ``or``. Як і інші логічні оператори, їхня "
"поведінка більш-менш відповідає тому, чого можна очікувати, зважаючи на їхні "
"назви. Наприклад, якщо я попрошу вас оцінити твердження «або ``2 + 2 = 4`` "
"*або* ``2 + 2 = 5``», ви скажете, що воно є істинним. Оскільки це твердження "
"типу «або-або», нам потрібно, щоб істинною була лише одна з двох частин. "
"Саме це і робить оператор ``or``:\\ [#]_"

#: ../../Ch06/Ch06_DataHandling_2.rst:133
msgid "Some more logical operators."
msgstr "Ще кілька логічних операторів."

#: ../../Ch06/Ch06_DataHandling_2.rst:139
msgid "not"
msgstr "не"

#: ../../Ch06/Ch06_DataHandling_2.rst:139
msgid "``NOT``"
msgstr "``NOT``"

#: ../../Ch06/Ch06_DataHandling_2.rst:139
msgid "``NOT(1==1)``"
msgstr "``NOT(1==1)``"

#: ../../Ch06/Ch06_DataHandling_2.rst:141
msgid "or"
msgstr "або"

#: ../../Ch06/Ch06_DataHandling_2.rst:141
msgid "``or``"
msgstr "``or``"

#: ../../Ch06/Ch06_DataHandling_2.rst:141
msgid "``(1==1) or (2==3)``"
msgstr "``(1==1) or (2==3)``"

#: ../../Ch06/Ch06_DataHandling_2.rst:143
msgid "and"
msgstr "і"

#: ../../Ch06/Ch06_DataHandling_2.rst:143
msgid "``and``"
msgstr "``and``"

#: ../../Ch06/Ch06_DataHandling_2.rst:143
msgid "``(1==1) and (2==3)``"
msgstr "``(1==1) and (2==3)``"

#: ../../Ch06/Ch06_DataHandling_2.rst:146
msgid ""
"On the other hand, if I ask you to assess the claim that “both 2 + 2 = 4 "
"*and* 2 + 2 = 5” you’d say that it’s false. Since this is an *and* statement "
"we need both parts to be true. And that’s what the ``and`` operator does:"
msgstr ""
"З іншого боку, якщо я попрошу вас оцінити твердження «2 + 2 = 4 *і* 2 + 2 = "
"5», ви скажете, що воно неправдиве. Оскільки це твердження з оператором *і*, "
"обидві частини повинні бути правдивими. І саме це робить оператор ``і``:"

#: ../../Ch06/Ch06_DataHandling_2.rst:154
msgid ""
"Finally, there’s the *not* operator, which is simple but annoying to "
"describe in English. If I ask you to assess my claim that “it is not true "
"that ``2 + 2 = 5``” then you would say that my claim is true, because "
"actually my claim is that “``2 + 2 = 5`` is false”. And I’m right. If we "
"write this in jamovi we use this:"
msgstr ""
"Нарешті, є оператор *not*, який є простим, але його важко описати "
"англійською мовою. Якщо я попрошу вас оцінити моє твердження, що «неправда, "
"що ``2 + 2 = 5``», ви скажете, що моє твердження є правдивим, тому що "
"насправді я стверджую, що «``2 + 2 = 5`` є неправдою». І я маю рацію. Якщо "
"ми запишемо це в jamovi, ми використаємо таке:"

#: ../../Ch06/Ch06_DataHandling_2.rst:164
msgid ""
"In other words, since ``2 + 2 == 5`` is a ``FALSE`` statement, it must be "
"the case that ``NOT(2 + 2 == 5)`` is a ``TRUE`` one. Essentially, what we’ve "
"really done is claim that “not false” is the same thing as “true”. "
"Obviously, this isn’t really quite right in real life. But jamovi lives in a "
"much more black or white world. For jamovi everything is either ``TRUE`` or "
"``FALSE``. No shades of grey are allowed."
msgstr ""
"Іншими словами, оскільки ``2 + 2 == 5`` є ``FALSE`` твердження, має бути "
"так, що ``NOT(2 + 2 == 5)`` є ``TRUE`` 1. По суті, ми стверджуємо, що «не "
"хибно» те саме, що й «істина». Звісно, у реальному житті це не зовсім так. "
"Але jamovi живе у набагато більш чорно-білому світі. Для jamovi все або "
"``TRUE`` або ``FALSE``. Відтінки сірого не допускаються."

#: ../../Ch06/Ch06_DataHandling_2.rst:171
msgid ""
"Of course, in our ``2 + 2 = 5`` example, we didn’t really need to use the "
"“not” operator ``NOT`` and the “equals to” operator ``==`` as two separate "
"operators. We could have just used the “not equals to” operator ``!=`` like "
"this:"
msgstr ""
"Звичайно, у нашому прикладі ``2 + 2 = 5`` нам не було необхідності "
"використовувати оператор «не» ``NOT`` та оператор дорівнює ``==`` як два "
"окремі оператори. Ми могли б просто використати оператор «не дорівнює» ``!=``"
" ось так:"

#: ../../Ch06/Ch06_DataHandling_2.rst:181
msgid "Applying logical operation to text"
msgstr "Застосування логічної операції до тексту"

#: ../../Ch06/Ch06_DataHandling_2.rst:183
msgid ""
"I also want to briefly point out that you can apply these logical operators "
"to text as well as to logical data. It’s just that we need to be a bit more "
"careful in understanding how jamovi interprets the different operations. In "
"this section I’ll talk about how the equal to operator ``==`` applies to "
"text, since this is the most important one. Obviously, the not equal to "
"operator ``!=`` gives the exact opposite answers to ``==`` so I’m implicitly "
"talking about that one too, but I won’t give specific commands showing the "
"use of ``!=``."
msgstr ""
"Я також хочу коротко зазначити, що ці логічні оператори можна застосовувати "
"як до тексту, так і до логічних даних. Просто нам потрібно бути трохи "
"обережнішими у розумінні того, як jamovi інтерпретує різні операції. У цьому "
"розділі я розповім про те, як оператор рівності ``==`` застосовується до "
"тексту, оскільки це найважливіший оператор. Очевидно, що оператор «не "
"дорівнює» ``!=`` дає відповіді, прямо протилежні ``==``, тому я непрямо "
"говорю і про нього, але не буду наводити конкретні команди, що демонструють "
"використання ``!=``."

#: ../../Ch06/Ch06_DataHandling_2.rst:192
msgid ""
"Okay, let’s see how it works. In one sense, it’s very simple. For instance, "
"I can ask jamovi if the word ``cat`` is the same as the word ``dog``, like "
"this:"
msgstr ""
"Добре, давайте подивимося, як це працює. З одного боку, це дуже просто. "
"Наприклад, я можу запитати jamovi, чи слово ``cat`` те саме, що й слово "
"``dog``, ось так:"

#: ../../Ch06/Ch06_DataHandling_2.rst:200
msgid ""
"That’s pretty obvious, and it’s good to know that even jamovi can figure "
"that out. Similarly, jamovi does recognise that a ``cat`` is a ``cat``:"
msgstr ""
"Це досить очевидно, і добре знати, що навіть jamovi може це зрозуміти. Так "
"само jamovi розпізнає, що ``cat`` є ``cat``:"

#: ../../Ch06/Ch06_DataHandling_2.rst:207
msgid ""
"Again, that’s exactly what we’d expect. However, what you need to keep in "
"mind is that jamovi is not at all tolerant when it comes to grammar and "
"spacing. If two strings differ in any way whatsoever, jamovi will say that "
"they’re not equal to each other, as with the following:"
msgstr ""
"Знову ж таки, це саме те, чого ми очікували. Однак, вам слід пам'ятати, що "
"jamovi абсолютно не терпить порушень граматики та пробілів. Якщо два рядки "
"хоч якось відрізняються між собою, jamovi визнає їх нерівними, як у "
"наведеному нижче прикладі:"

#: ../../Ch06/Ch06_DataHandling_2.rst:218
msgid ""
"You can also use other logical operators too. For instance jamovi also "
"allows you to use the ``<`` and ``>`` operators to determine which of two "
"text “strings” comes first, alphabetically speaking. Sort of. Actually, it’s "
"a bit more complicated than that, but let’s start with a simple example:"
msgstr ""
"Ви також можете використовувати інші логічні оператори. Наприклад, jamovi "
"також дозволяє використовувати оператори ``<`` та ``>`` для визначення, який "
"з двох текстових «рядків» йде першим за алфавітом. Приблизно так. Насправді "
"це трохи складніше, але давайте почнемо з простого прикладу:"

#: ../../Ch06/Ch06_DataHandling_2.rst:228
msgid ""
"In jamovi, this example evaluates to ``TRUE``. This is because ``cat`` does "
"does come before ``dog`` alphabetically, so jamovi judges the statement to "
"be true. However, if we ask jamovi to tell us if ``cat`` comes before "
"``anteater`` then it will evaluate the expression as ``FALSE``. So far, so "
"good. But text data is a bit more complicated than the dictionary suggests. "
"What about ``cat`` and ``CAT``? Which of these comes first? Try it and find "
"out:"
msgstr ""
"У jamovi цей приклад оцінюється як ``TRUE``. Це тому, що ``cat`` дійсно "
"стоїть перед ``dog`` в алфавітному порядку, тому jamovi вважає це твердження "
"істинним. Однак, якщо ми попросимо jamovi сказати нам, чи ``cat`` стоїть "
"перед ``anteater``, то він оцінить цей вираз як ``FALSE``. Поки що все "
"добре. Але текстові дані є дещо складнішими, ніж це можна уявити за "
"словником. А як щодо ``cat`` і ``CAT``? Яке з них йде першим? Спробуйте і "
"дізнайтеся:"

#: ../../Ch06/Ch06_DataHandling_2.rst:240
msgid ""
"This in fact evaluates to ``TRUE``. In other words, jamovi assumes that "
"uppercase letters come before lowercase ones. Fair enough. No-one is likely "
"to be surprised by that. What you might find surprising is that jamovi "
"assumes that *all* uppercase letters come before *all* lowercase ones. That "
"is, while ``\"anteater\" < \"zebra\"`` is a true statement, and the "
"uppercase equivalent ``\"ANTEATER\" < \"ZEBRA\"`` is also true, it is *not* "
"true to say that ``\"anteater\" < \"ZEBRA\"``, as the following extract "
"illustrates. Try this:"
msgstr ""
"Фактично це оцінюється як ``TRUE``. Іншими словами, jamovi припускає, що "
"великі літери йдуть перед малими. Це справедливо. Ніхто не буде здивований "
"цим. Що може вас здивувати, так це те, що jamovi припускає, що *всі* великі "
"літери йдуть перед *всіма* малими. Тобто, хоча ``\"anteater\" < \"zebra\"`` "
"є істинним твердженням, а його еквівалент, написаний великими літерами ``"
"\"ANTEATER\" < \"ZEBRA\"`` також правда, *неправда* стверджувати, що ``"
"\"anteater\" < \"ZEBRA\"``, як показано в наступному уривку. Спробуйте це:"

#: ../../Ch06/Ch06_DataHandling_2.rst:253
msgid ""
"This evaluates to ``FALSE``, and this may seem slightly counterintuitive. "
"With that in mind, it may help to have a quick look at the various text "
"characters in the order that jamovi processes them:"
msgstr ""
"Це обчислюється як ``FALSE``, і це може здатися дещо нелогічним. З огляду на "
"це, може бути корисним швидко поглянути на різні текстові символи в порядку, "
"в якому їх обробляє jamovi:"

#: ../../Ch06/Ch06_DataHandling_2.rst:266
msgid ""
"I offer up my teenage attempts to be “cool” as evidence that some things "
"just can’t be done."
msgstr ""
"Я пропоную свої підліткові спроби бути «крутим» як доказ того, що деякі речі "
"просто неможливо зробити."

#: ../../Ch06/Ch06_DataHandling_2.rst:270
msgid ""
"You can do this in the Compute new variable screen, though just calculating "
"``2 + 2`` for every cell of a new variable is not very useful!"
msgstr ""
"Ви можете зробити це на екрані «Обчислити нову змінну», хоча просте "
"обчислення ``2 + 2`` для кожної комірки нової змінної не дуже корисне!"

#: ../../Ch06/Ch06_DataHandling_2.rst:275
msgid ""
"Note that this is a very different operator to the equals operator ``=``. A "
"common typo that people make when trying to write logical commands in jamovi "
"(or other languages, since the “``=`` versus ``==``” distinction is "
"important in many computer and statistical programs) is to accidentally type "
"``=`` when you really mean ``==``. Be especially cautious with this, I’ve "
"been programming in various languages since I was a teenager and I *still* "
"screw this up a lot. Hmm. I think I see why I wasn’t cool as a teenager. And "
"why I’m still not cool."
msgstr ""
"Зверніть увагу, що це зовсім інший оператор, ніж оператор рівності ``=``. "
"Поширеною помилкою, яку роблять люди, намагаючись написати логічні команди в "
"jamovi (або інших мовах, оскільки розрізнення між «``=``» і «``==``» є "
"важливим у багатьох комп'ютерних і статистичних програмах), є випадкове "
"введення «``=``», коли насправді мається на увазі «``==``». Будьте особливо "
"обережні з цим, я програмую на різних мовах з підліткового віку і *досі* "
"часто плутаю ці символи. Хм. Гадаю, я розумію, чому я не був крутим "
"підлітком. І чому я досі не крутий."

#: ../../Ch06/Ch06_DataHandling_2.rst:286
msgid ""
"Now, here’s a quirk in jamovi. When you have simple logical expressions like "
"the ones we have already met, e.g. ``2 + 2 == 5`` then jamovi neatly states "
"``FALSE`` (or ``TRUE``) in the corresponding spreadsheet column. Underneath "
"the hood, jamovi stores ``FALSE`` as ``0`` and ``TRUE`` as ``1``. When we "
"have more complex logical expressions, such as ``(2 + 2 == 4) or (2 + 2 == "
"5)``, then jamovi just displays either ``0`` or ``1``, depending whether the "
"logical expression is evaluated as false, or true."
msgstr ""
"Тепер, ось одна особливість jamovi. Коли ви маєте прості логічні вирази, як "
"ті, що ми вже зустрічали, наприклад, ``2 + 2 == 5``, то jamovi чітко вказує "
"``FALSE`` (або ``TRUE``) у відповідному стовпці електронної таблиці. "
"Внутрішньо jamovi зберігає ``FALSE`` як ``0``, а ``TRUE`` як ``1``. Коли ми "
"маємо більш складні логічні вирази, такі як ``(2 + 2 == 4) або (2 + 2 == 5)``"
", то jamovi просто відображає або ``0``, або ``1``, залежно від того, чи "
"логічний вираз оцінюється як хибний, чи істинний."

#: ../../Ch06/Ch06_DataHandling_3.rst:4
msgid "Transforming and recoding a variable"
msgstr "Перетворення та перекодування змінної"

#: ../../Ch06/Ch06_DataHandling_3.rst:6
msgid ""
"It’s not uncommon in real world data analysis to find that one of your "
"variables isn’t quite equivalent to the variable that you really want. For "
"instance, it’s often convenient to take a continuous variable |continuous| "
"(e.g., age) and break it up into a smallish number of categories (e.g., "
"younger, middle, older). At other times, you may need to convert a numeric "
"variable into a different numeric variable (e.g., you may want to analyse at "
"the absolute value of the original variable). In this section I’ll describe "
"a few key ways you can do these things in jamovi."
msgstr ""
"У реальному аналізі даних нерідко трапляється, що одна з ваших змінних не "
"зовсім відповідає змінній, яка вам насправді потрібна. Наприклад, часто "
"зручно взяти безперервну змінну |continuous| (наприклад, вік) і розділити її "
"на невелику кількість категорій (наприклад, молодший, середній, старший). В "
"інших випадках може знадобитися перетворити числову змінну в іншу числову "
"змінну (наприклад, ви можете захотіти проаналізувати абсолютне значення "
"вихідної змінної). У цьому розділі я опишу кілька основних способів, як це "
"можна зробити в jamovi."

#: ../../Ch06/Ch06_DataHandling_3.rst:298
msgid "continuous"
msgstr "continuous"

#: ../../Ch06/Ch06_DataHandling_3.rst:16
msgid "Creating a transformed variable"
msgstr "Створення перетвореної змінної"

#: ../../Ch06/Ch06_DataHandling_3.rst:18
msgid ""
"The first trick to discuss is the idea of **transforming** a variable. Taken "
"literally, *anything* you do to a variable is a transformation, but in "
"practice what it usually means is that you apply a relatively simple "
"mathematical function to the original variable in order to create a new "
"variable that either (a) provides a better way of describing the thing "
"you’re actually interested in, or (b) is more closely in agreement with the "
"assumptions of the statistical tests you want to do. Since, at this stage, I "
"haven’t talked about statistical tests or their assumptions, I’ll show you "
"an example based on the first case."
msgstr ""
"Перший трюк, який слід обговорити, — це ідея **трансформації** змінної. У "
"буквальному розумінні *будь-яка* операція над змінною є перетворенням, але "
"на практиці це зазвичай означає, що ви застосовуєте відносно просту "
"математичну функцію до вихідної змінної, щоб створити нову змінну, яка або "
"(а) забезпечує кращий спосіб опису того, що вас насправді цікавить, або (б) "
"більш точно відповідає припущенням статистичних тестів, які ви хочете "
"провести. Оскільки на цьому етапі я ще не говорив про статистичні тести та "
"їхні припущення, я покажу вам приклад, заснований на першому випадку."

#: ../../Ch06/Ch06_DataHandling_3.rst:28
msgid ""
"Suppose I’ve run a short study in which I ask 10 people a single question:"
msgstr ""
"Припустимо, я провів коротке дослідження, в якому ставлю 10 людям одне "
"питання:"

#: ../../Ch06/Ch06_DataHandling_3.rst:31
msgid ""
"On a scale of 1 (strongly disagree) to 7 (strongly agree), to what extent do "
"you agree with the proposition that “Dinosaurs are awesome”?"
msgstr ""
"За шкалою від 1 (категорично не згоден) до 7 (категорично згоден), наскільки "
"ви погоджуєтеся з твердженням, що «динозаври приголомшливі»?"

#: ../../Ch06/Ch06_DataHandling_3.rst:35
msgid ""
"Now let’s load and look at the data. The |likert|_ data set contains a "
"single variable that contains raw Likert-scale responses for these 10 "
"people. However, if you think about it, this isn’t the best way to represent "
"these responses. Because of the fairly symmetric way that we set up the "
"response scale, there’s a sense in which the midpoint of the scale should "
"have been coded as 0 (no opinion), and the two endpoints should be **+3** "
"(strongly agree) and **-3** (strongly disagree). By recoding the data in "
"this way it’s a bit more reflective of how we really think about the "
"responses. The recoding here is pretty straightforward, we just subtract 4 "
"from the raw scores. In jamovi you can do this by computing a new variable: "
"click on the ``Compute`` button in the ``Data`` tab and you will see that a "
"new variable has been added to the spreadsheet. Let’s call this new variable "
"``likert.centred`` (go ahead and type that in) and then add the following in "
"the formula box, like in :numref:`fig-likertraw`: ``likert.raw - 4``"
msgstr ""
"Тепер завантажимо і розглянемо дані. Набір даних |likert|_ містить одну "
"змінну, яка містить необроблені відповіді за шкалою Лікерта для цих 10 осіб. "
"Однак, якщо задуматися, це не найкращий спосіб представлення цих відповідей. "
"Оскільки ми встановили досить симетричну шкалу відповідей, в певному сенсі "
"середина шкали повинна була бути закодована як 0 (не маю думки), а дві "
"крайні точки — як **+3** (повністю згоден) і **-3** (повністю не згоден). "
"Перекодування даних таким чином дещо краще відображає те, як ми насправді "
"сприймаємо відповіді. Перекодування тут досить просте, ми просто віднімаємо "
"4 від необроблених балів. У jamovi це можна зробити, обчисливши нову змінну: "
"натисніть кнопку ``Обчислити`` на вкладці ``Дані``, і ви побачите, що до "
"таблиці додано нову змінну. Назвемо цю нову змінну ``likert.centred`` ("
"введіть це ім'я) і додамо наступне у вікно формули, як у :numref:`fig-"
"likertraw`: ``likert.raw - 4``"

#: ../../Ch06/Ch06_DataHandling_3.rst:52 ../../Ch06/Ch06_DataHandling_3.rst:56
msgid "Creating a new computed variable in jamovi"
msgstr "Створення нової обчислюваної змінної в jamovi"

#: ../../Ch06/Ch06_DataHandling_3.rst:60
msgid ""
"One reason why it might be useful to have the data in this format is that "
"there are a lot of situations where you might prefer to analyse the "
"*strength* of the opinion separately from the *direction* of the opinion. We "
"can do two different transformations on this ``likert.centred`` variable in "
"order to distinguish between these two different concepts. First, to compute "
"an ``opinion.strength`` variable, we want to take the absolute value of the "
"centred data (using the ``ABS`` function).\\ [#]_ In jamovi, create another "
"new variable using the ``Compute`` button. Name the variable ``opinion."
"strength`` and this time click on the *f*\\ :sub:`x` button next to the "
"``Formula`` box. This shows the different ``Functions`` and ``Variables`` "
"that you can add to the ``Formula`` box, so double click on ``ABS`` and then "
"double click on ``likert.centred`` and you will see that the ``Formula`` box "
"is populated with ``ABS(likert.centred)`` and a new variable has been "
"created in the spreadsheet view, as in :numref:`fig-opinionstrength`:"
msgstr ""
"Однією з причин, чому може бути корисно мати дані в цьому форматі, є те, що "
"існує багато ситуацій, коли ви можете вважати за краще аналізувати *силу* "
"думки окремо від *напрямку* думки. Ми можемо виконати два різних "
"перетворення цієї змінної ``likert.centred``, щоб розрізнити ці два різних "
"поняття. По-перше, щоб обчислити змінну ``opinion.strength``, ми хочемо "
"взяти абсолютне значення центрованих даних (використовуючи функцію ``ABS``)."
"\\ [#]_ У jamovi створіть ще одну нову змінну за допомогою кнопки ``Compute``"
". Назвіть змінну ``opinion.strength`` і цього разу натисніть кнопку *f*\\ "
":sub:`x` поруч із полем ``Formula``. Це покаже різні ``Функції`` та "
"``Змінні``, які ви можете додати до поля ``Формула``, тому двічі клацніть на "
"``ABS``, а потім двічі клацніть на ``likert.centred``, і ви побачите, що "
"поле ``Формула`` заповнюється ``ABS(likert.centred)``, а в таблиці буде "
"створено нову змінну, як показано на :numref:`fig-opinionstrength`:"

#: ../../Ch06/Ch06_DataHandling_3.rst:78
msgid "*f*\\ :sub:`x` button to select functions and variables"
msgstr "*f*\\ :sub:`x` кнопка для вибору функцій та змінних"

#: ../../Ch06/Ch06_DataHandling_3.rst:82
msgid "Using the *f*\\ :sub:`x` button to select functions and variables"
msgstr "Використання кнопки *f*\\ :sub:`x` для вибору функцій та змінних"

#: ../../Ch06/Ch06_DataHandling_3.rst:86
msgid ""
"Second, to compute a variable that contains only the direction of the "
"opinion and ignores the strength, we want to calculate the “sign” of the "
"variable. In jamovi we can use the ``IF`` function to do this. Create "
"another new variable using the ``Compute`` button, name this one ``opinion."
"sign``, and then type the following into the function box:"
msgstr ""
"По-друге, щоб обчислити змінну, яка містить тільки напрямок думки та ігнорує "
"її силу, ми хочемо обчислити «знак» змінної. У jamovi для цього можна "
"використати функцію ``IF``. Створіть ще одну нову змінну за допомогою кнопки "
"``Compute``, назвіть її ``opinion.sign``, а потім введіть у поле функції "
"наступне:"

#: ../../Ch06/Ch06_DataHandling_3.rst:96
msgid ""
"When done, you’ll see that all negative numbers from the ``likert.centred`` "
"variable are converted to **-1**, all positive numbers are converted to "
"**1** and zero stays as **0**, like so:"
msgstr ""
"Після завершення ви побачите, що всі від'ємні числа зі змінної "
"``likert.centred`` перетворюються на **-1**, всі додатні числа "
"перетворюються на **1**, а нуль залишається як **0**, ось так:"

#: ../../Ch06/Ch06_DataHandling_3.rst:104
msgid ""
"Let’s break down what this ``IF`` command is doing. In jamovi there are "
"three parts to an ``IF`` statement, written as ``IF(expression, value, "
"else)``. The first part, ``expression`` can be a logical or mathematical "
"statement. In our example, we have specified ``likert.centred == 0``, which "
"is ``TRUE`` for values where ``likert.centred`` is zero. The next part, "
"``value``, is the new value where the expression in part one is ``TRUE``. In "
"our example, we have said that for all those values where ``likert.centred`` "
"is zero, keep them zero. In the next part, ``else``, we can enter another "
"logical or mathematical statement to be used if part one evaluates to "
"``FALSE``, i.e. where ``likert.centred`` is not zero. In our example we have "
"divided ``likert.centred`` by opinion.strength to give ``-1`` or ``+1`` "
"depending of the sign of the original value in ``likert.centred``.\\ [#]_"
msgstr ""
"Давайте розберемо, що це ``IF`` команда виконується. У jamovi є три частини "
"``IF`` твердження, записане як ``IF(expression, value, else)``. Перший "
"частина, ``expression`` може бути логічним або математичним твердженням. У "
"нашому прикладі ми вказали ``likert.centred == 0``, який є ``TRUE`` для "
"значень, де ``likert.centred`` дорівнює нулю. Наступна частина, ``value``, – "
"це нове значення, де вираз у першій частині має вигляд ``TRUE``. У нашому "
"прикладі ми сказали, що для всіх тих значень, де ``likert.centred`` дорівнює "
"нулю, залиште їх нульовими. У наступній частині, ``else``, ми можемо ввести "
"інше логічне або математичне твердження, яке буде використано, якщо перша "
"частина обчислюється як ``FALSE``, тобто де ``likert.centred`` не дорівнює "
"нулю. У нашому прикладі ми поділили ``likert.centred`` за думкою.сила давати "
"``-1`` або ``+1`` залежно від знака початкового значення в "
"``likert.centred``.\\ [#]_"

#: ../../Ch06/Ch06_DataHandling_3.rst:117
msgid ""
"And we’re done. We now have three shiny new variables, all of which are "
"useful transformations of the original ``likert.raw`` variable."
msgstr ""
"І ми закінчили. Тепер у нас є три нові блискучі змінні, всі з яких є "
"корисними перетвореннями оригінальної змінної ``likert.raw``."

#: ../../Ch06/Ch06_DataHandling_3.rst:121
msgid ""
"Collapsing a variable into a smaller number of discrete levels or categories"
msgstr "Згортання змінної на меншу кількість дискретних рівнів або категорій"

#: ../../Ch06/Ch06_DataHandling_3.rst:123
msgid ""
"One pragmatic task that comes up quite often is the problem of collapsing a "
"variable into a smaller number of discrete levels or categories. For "
"instance, suppose I’m interested in looking at the age distribution of "
"people at a social gathering:"
msgstr ""
"Одним із практичних завдань, яке виникає досить часто, є проблема зведення "
"змінної до меншої кількості дискретних рівнів або категорій. Наприклад, "
"припустимо, я зацікавлений у розподілі людей за віком на соціальному заході:"

#: ../../Ch06/Ch06_DataHandling_3.rst:132
msgid ""
"In some situations it can be quite helpful to group these into a smallish "
"number of categories. For example, we could group the data into three broad "
"categories: young (0-20), adult (21-40) and older (41-60). This is a quite "
"coarse-grained classification, and the labels that I’ve attached only make "
"sense in the context of this data set (e.g., viewed more generally, a 42 "
"year old wouldn’t consider themselves as “older”). We can slice this "
"variable up quite easily using the jamovi ``IF`` function that we have "
"already used. This time we have to specify nested ``IF`` statements, meaning "
"simply that ``IF`` the first logical expression is ``TRUE``, insert a first "
"value, but ``IF`` a second logical expression is ``TRUE``, insert a second "
"value, but ``IF`` a third logical expression is ``TRUE``, then insert a "
"third value. This can be written as:"
msgstr ""
"У деяких ситуаціях може бути досить корисно згрупувати їх у невелику "
"кількість категорій. Наприклад, ми могли б згрупувати дані у три широкі "
"категорії: молоді (0-20), дорослі (21-40) та літні (41-60). Це досить груба "
"класифікація, і позначки, які я додав, мають сенс лише в контексті цього "
"набору даних (наприклад, якщо дивитися більш загально, 42-річна людина не "
"вважатиме себе «літньою»). Ми можемо досить легко розділити цю змінну за "
"допомогою функції jamovi ``IF``, яку ми вже використовували. Цього разу ми "
"маємо вказати вкладені оператори ``IF``, що означає просто: ``IF`` перший "
"логічний вираз є ``TRUE``, вставте перше значення, але ``IF`` другий "
"логічний вираз є ``TRUE``, вставте друге значення, але ``IF`` третій "
"логічний вираз є ``TRUE``, вставте третє значення. Це можна записати так:"

#: ../../Ch06/Ch06_DataHandling_3.rst:149
msgid ""
"Note that there are three left parentheses used during the nesting, so the "
"whole statement has to end with three right parentheses otherwise you will "
"get an error message. The jamovi screen shot for this data manipulation, "
"along with an accompanying frequency table, is shown in :numref:`fig-"
"agecats`:"
msgstr ""
"Зверніть увагу, що під час вкладання використовуються три ліві дужки, тому "
"вся інструкція повинна закінчуватися трьома правими дужками, інакше ви "
"отримаєте повідомлення про помилку. Знімок екрана jamovi для цієї обробки "
"даних, а також супровідна таблиця частот, показані в :numref:`fig-agecats`:"

#: ../../Ch06/Ch06_DataHandling_3.rst:157
msgid "Using the ``IF`` function"
msgstr "Використання функції ``IF``"

#: ../../Ch06/Ch06_DataHandling_3.rst:161
msgid ""
"Collapsing a variable into a smaller number of discrete levels using the "
"jamovi ``IF`` function"
msgstr ""
"Згортання змінної на меншу кількість дискретних рівнів за допомогою функції "
"jamovi ``IF``"

#: ../../Ch06/Ch06_DataHandling_3.rst:166
msgid ""
"It’s important to take the time to figure out whether or not the resulting "
"categories make any sense at all in terms of your research project. If they "
"don’t make any sense to you as meaningful categories, then any data analysis "
"that uses those categories is likely to be just as meaningless. More "
"generally, in practice I’ve noticed that people have a very strong desire to "
"carve their (continuous and messy) data into a few (discrete and simple) "
"categories, and then run analyses using the categorised data instead of the "
"original data.\\ [#]_ I wouldn’t go so far as to say that this is an "
"inherently bad idea, but it does have some fairly serious drawbacks at "
"times, so I would advise some caution if you are thinking about doing it."
msgstr ""
"Важливо приділити час, щоб з'ясувати, чи мають отримані категорії якийсь "
"сенс з точки зору вашого дослідницького проекту. Якщо вони не мають для вас "
"сенсу як значущі категорії, то будь-який аналіз даних, що використовує ці "
"категорії, ймовірно, буде таким же безглуздим. Взагалі, на практиці я "
"помітив, що люди мають дуже сильне бажання розділити свої (безперервні та "
"хаотичні) дані на кілька (дискретних та простих) категорій, а потім "
"проводити аналіз, використовуючи категоризовані дані замість вихідних даних. "
"[#]_ Я не став би стверджувати, що це в принципі погана ідея, але іноді вона "
"має досить серйозні недоліки, тому я б радив бути обережним, якщо ви думаєте "
"про це."

#: ../../Ch06/Ch06_DataHandling_3.rst:179
msgid "Creating a transformation that can be applied to multiple variables"
msgstr "Створення перетворення, яке можна застосувати до кількох змінних"

#: ../../Ch06/Ch06_DataHandling_3.rst:181
msgid ""
"Sometimes you want to apply the same transformation to more than one "
"variable, for example when you have multiple questionnaire items that all "
"need to be recalculated or recoded in the same way. And one of the neat "
"features in jamovi is that you can create a transformation, using the "
"``Transform`` button in the ``Data`` tab, that can then be saved and applied "
"to multiple variables. Let’s go back to the first example above, using the |"
"likert|_ data set that contains a single variable with raw Likert-scale "
"responses for 10 people. To create a transformation that you can save and "
"then apply across multiple variables (assuming you had more variables like "
"this in your data file), first in the spreadsheet editor select (i.e., "
"click) the variable you want to use to initially create the transformation. "
"In our example this is ``likert.raw``. Next click the ``Transform`` button "
"in the jamovi ``Data`` tab, and you’ll see something like :numref:`fig-"
"transform1`."
msgstr ""
"Іноді ви хочете застосувати одне і те ж перетворення до декількох змінних, "
"наприклад, коли у вас є кілька пунктів анкети, які потрібно перерахувати або "
"перекодувати одним і тим же способом. Однією з зручних функцій jamovi є те, "
"що ви можете створити перетворення за допомогою кнопки ``Transform`` на "
"вкладці ``Data``, яке потім можна зберегти і застосувати до декількох "
"змінних. Повернемося до першого прикладу вище, використовуючи набір даних |"
"likert_, який містить одну змінну з необробленими відповідями за шкалою "
"Лікерта для 10 осіб. Щоб створити перетворення, яке можна зберегти, а потім "
"застосувати до декількох змінних (припускаючи, що у вашому файлі даних є "
"більше таких змінних), спочатку в редакторі електронних таблиць виберіть ("
"тобто клацніть) змінну, яку ви хочете використовувати для початкового "
"створення перетворення. У нашому прикладі це ``likert.raw``. Далі натисніть "
"кнопку ``Transform`` у вкладці jamovi ``Data``, і ви побачите щось на зразок "
":numref:`fig-transform1`."

#: ../../Ch06/Ch06_DataHandling_3.rst:198
msgid "Using the jamovi ``Transform`` command"
msgstr "Використання команди jamovi ``Transform``"

#: ../../Ch06/Ch06_DataHandling_3.rst:202
msgid ""
"Creating a new variable transformation using the jamovi ``Transform`` command"
msgstr ""
"Створення нового перетворення змінних за допомогою команди jamovi "
"``Transform``"

#: ../../Ch06/Ch06_DataHandling_3.rst:207
msgid ""
"Give your new variable a name, let’s call it ``opinion.strength`` and then "
"click on the ``Using transform`` selection box and select ``Create New "
"Transform…``. This is where you will create, and name, the transformation "
"that can be re-applied to as many variables as you like. The transformation "
"is automatically named for us as ``Transform 1`` (imaginative, huh. You can "
"change this if you like). Then type the expression ``ABS($source - 4)`` into "
"the function text box, as in :numref:`fig-transform2`, press Enter or Return "
"on your keyboard and, hey presto, you have created a new transformation and "
"applied it to the ``likert.raw`` variable! Good, eh. Note that instead of "
"using the variable label in the expression, we have instead used "
"``$source``. This is so that we can then use the same transformation with as "
"many different variables as we like - jamovi requires you to use ``$source`` "
"to refer to the source variable you are transforming. Your transformation "
"has also been saved and can be re-used any time you like (providing you save "
"the dataset as an ``.omv`` file, otherwise you’ll lose it!)."
msgstr ""
"Дайте новій змінній ім'я, назвемо її ``opinion.strength``, а потім натисніть "
"на поле вибору ``Using transform`` і виберіть ``Create New Transform…``. Тут "
"ви створите і назвете перетворення, яке можна буде повторно застосувати до "
"будь-якої кількості змінних. Перетворення автоматично отримає ім'я ``"
"Transform 1`` (дуже оригінально, правда? Ви можете змінити це ім'я, якщо "
"хочете). Потім введіть вираз ``ABS($source - 4)`` у текстове поле функції, "
"як у :numref:`fig-transform2`, натисніть Enter або Return на клавіатурі, і "
"ось, ви створили нове перетворення та застосували його до змінної "
"``likert.raw``! Чудово, еге ж? Зверніть увагу, що замість використанням "
"мітки змінної у виразі ми використали ``$source``. Це зроблено для того, щоб "
"ми могли використовувати те саме перетворення з будь-якою кількістю різних "
"змінних — jamovi вимагає використання ``$source`` для посилання на вихідну "
"змінну, яку ви перетворюєте. Ваше перетворення також було збережено і може "
"бути повторно використане в будь-який час (за умови, що ви зберегли набір "
"даних як файл ``.omv``, інакше ви його втратите!)."

#: ../../Ch06/Ch06_DataHandling_3.rst:226
msgid "Specifying a transformation in jamovi"
msgstr "Визначення перетворення в jamovi"

#: ../../Ch06/Ch06_DataHandling_3.rst:230
msgid ""
"Specifying a transformation in jamovi, to be saved as the imaginatively "
"named ``Transform 1``"
msgstr ""
"Визначення перетворення в jamovi, яке буде збережено під оригінальною назвою "
"``Transform 1``"

#: ../../Ch06/Ch06_DataHandling_3.rst:235
msgid ""
"You can also create a transformation with the second example we looked at, "
"the age distribution of people at a social gathering. Go on, you know you "
"want to! Remember that we collapsed this variable into three groups: "
"younger, adult and older. This time we will achieve the same thing, but "
"using the jamovi ``Transform`` → ``Add condition`` button. With this data "
"set (go back to it or create it again if you didn’t save it) set up a new "
"variable transformation. Call the transformed variable ``AgeCats`` and the "
"transformation you will create ``Agegroupings``. Then click on the big ``+`` "
"sign next to the function box. This is the ``Add condition`` button and I’ve "
"stuck a big red arrow onto :numref:`fig-transform3` so you can see exactly "
"where this is. Re-create the transformation shown in :numref:`fig-"
"transform3` and when you have done, you will see the new values appear in "
"the spreadsheet window. What’s more, the ``Agegroupings`` transformation has "
"been saved and can be re-applied any time you like. Ok, so I know that it’s "
"unlikely you will have more than one ``Age`` variable, but you get the idea "
"now of how to set up transformations in jamovi, so you can follow this idea "
"with other sorts of variables. A typical scenario for this is when you have "
"a questionnaire scale with, say, 20 items (variables) and each item was "
"originally scored from 1 to 6 but, for some reason or quirk of the data you "
"decide to recode all the items as 1 to 3. You can easily do this in jamovi "
"by creating and then re-applying your transformation for each variable that "
"you want to recode."
msgstr ""
"Ви також можете створити перетворення за допомогою другого прикладу, який ми "
"розглядали, — розподілу людей за віком на соціальному заході. Давайте, ви ж "
"знаєте, що хочете це зробити! Пам'ятайте, що ми об'єднали цю змінну в три "
"групи: молодші, дорослі та старші. Цього разу ми досягнемо того ж "
"результату, але за допомогою кнопки jamovi ``Transform`` → ``Add condition``"
". З цим набором даних (поверніться до нього або створіть його знову, якщо ви "
"його не зберегли) налаштуйте нову трансформацію змінної. Назвіть "
"трансформовану змінну ``AgeCats``, а трансформацію, яку ви створите, — "
"``Agegroupings``. Потім натисніть на великий знак ``+`` поруч із полем "
"функції. Це кнопка ``Add condition``, і я наклеїв велику червону стрілку на "
":numref:`fig-transform3`, щоб ви точно бачили, де вона знаходиться. Створіть "
"перетворення, показане на :numref:`fig-transform3`, і коли ви це зробите, ви "
"побачите нові значення у вікні електронної таблиці. Більше того, "
"перетворення ``Вікові групи`` було збережено і його можна застосувати знову "
"в будь-який час. Гаразд, я знаю, що навряд чи у вас буде більше однієї "
"змінної ``Вік``, але тепер ви розумієте, як налаштовувати перетворення в "
"jamovi, тож можете застосувати цю ідею до інших типів змінних. Типовий "
"сценарій для цього — коли у вас є шкала анкети, скажімо, з 20 пунктами "
"(змінними), і кожен пункт спочатку оцінювався від 1 до 6, але з якоїсь "
"причини або через особливості даних ви вирішили перекодувати всі пункти від "
"1 до 3. Ви можете легко зробити це в jamovi, створивши і потім повторно "
"застосувавши перетворення для кожної змінної, яку ви хочете перекодувати."

#: ../../Ch06/Ch06_DataHandling_3.rst:259
msgid "jamovi transformation into categories"
msgstr "перетворення jamovi на категорії"

#: ../../Ch06/Ch06_DataHandling_3.rst:263
msgid ""
"jamovi transformation into three age categories, using the ``Add condition`` "
"button"
msgstr ""
"перетворення jamovi на три вікові категорії за допомогою кнопки ``Add "
"condition``"

#: ../../Ch06/Ch06_DataHandling_3.rst:271
msgid ""
"The absolute value of a number is its distance from zero, regardless of "
"whether it’s sign is negative or positive."
msgstr ""
"Абсолютне значення числа — це його відстань від нуля, незалежно від того, чи "
"його знак від'ємний, чи додатний."

#: ../../Ch06/Ch06_DataHandling_3.rst:275
msgid ""
"The reason we have to use the ``IF`` command and keep zero as zero is that "
"you cannot just use ``likert.centred / opinion.strength`` to calculate the "
"sign of ``likert.centred``, because mathematically dividing zero by zero "
"does not work. Try it and see."
msgstr ""
"Причина, по якій ми маємо використовувати команду ``IF`` і зберігати нуль як "
"нуль, полягає в тому, що ви не можете просто використовувати ``"
"likert.centred / opinion.strength`` для обчислення знака ``likert.centred``, "
"оскільки математичне ділення нуля на нуль не працює. Спробуйте і "
"переконайтеся в цьому."

#: ../../Ch06/Ch06_DataHandling_3.rst:281
msgid ""
"If you’ve read further into the book, and are re-reading this section, then "
"a good example of this would be someone choosing to do an ANOVA using "
"``AgeCats`` as the grouping variable, instead of running a regression using "
"``Age`` as a predictor. There are sometimes good reasons for doing this. For "
"instance, if the relationship between ``Age`` and your outcome variable is "
"highly non-linear and you aren’t comfortable with trying to run non-linear "
"regression! However, unless you really do have a good rationale for doing "
"this, it’s best not to. It tends to introduce all sorts of other problems (e."
"g., the data will probably violate the normality assumption) and you can "
"lose a lot of statistical power."
msgstr ""
"Якщо ви прочитали книгу далі і перечитуєте цей розділ, то хорошим прикладом "
"цього може бути вибір когось, хто вирішив виконати ANOVA, використовуючи "
"``AgeCats`` як змінну групування, замість того, щоб виконати регресію, "
"використовуючи ``Age`` як предиктор. Іноді для цього є вагомі причини. "
"Наприклад, якщо взаємозв'язок між ``Age`` і вашою змінною результату є вкрай "
"нелінійним, а ви не впевнені у своїх силах, намагаючись виконати нелінійну "
"регресію! Однак, якщо у вас немає дійсно вагомих підстав для цього, краще "
"цього не робити. Це може спричинити цілу низку інших проблем (наприклад, "
"дані, ймовірно, порушать припущення про нормальність) і ви можете втратити "
"значну частину статистичної сили."

#: ../../Ch06/Ch06_DataHandling_4.rst:4
msgid "Mathematical functions and operations"
msgstr "Математичні функції та операції"

#: ../../Ch06/Ch06_DataHandling_4.rst:6
msgid ""
"In the previous section, I discussed the ideas behind variable "
"transformations and showed that a lot of the transformations that you might "
"want to apply to your data are based on fairly simple mathematical functions "
"and operations. In this section I want to return to that discussion and "
"mention several other mathematical functions and arithmetic operations that "
"are actually quite useful for a lot of real world data analysis. :numref:"
"`tab-mathfunc` gives a brief overview of the various mathematical functions "
"I want to talk about here, or later.\\ [#]_ Obviously this doesn’t even come "
"close to cataloguing the range of possibilities available, but it does cover "
"a range of functions that are used regularly in data analysis and that are "
"available in jamovi."
msgstr ""
"У попередньому розділі я обговорив ідеї, що лежать в основі перетворень "
"змінних, і показав, що багато перетворень, які ви можете застосувати до "
"своїх даних, базуються на досить простих математичних функціях і операціях. "
"У цьому розділі я хочу повернутися до цієї теми і згадати кілька інших "
"математичних функцій та арифметичних операцій, які насправді є досить "
"корисними для аналізу багатьох реальних даних. :numref:`tab-mathfunc` дає "
"короткий огляд різних математичних функцій, про які я хочу поговорити тут "
"або пізніше. [#]_ Звичайно, це навіть не наближається до каталогізації "
"всього спектру доступних можливостей, але охоплює ряд функцій, які регулярно "
"використовуються в аналізі даних і доступні в jamovi."

#: ../../Ch06/Ch06_DataHandling_4.rst:17
msgid "Some of the mathematical functions available in jamovi"
msgstr "Деякі математичні функції, доступні в jamovi"

#: ../../Ch06/Ch06_DataHandling_4.rst:21
msgid "Function"
msgstr "Функція"

#: ../../Ch06/Ch06_DataHandling_4.rst:21
msgid "Example input"
msgstr "Приклад введення"

#: ../../Ch06/Ch06_DataHandling_4.rst:21
msgid "result"
msgstr "результат"

#: ../../Ch06/Ch06_DataHandling_4.rst:23
msgid "Square root"
msgstr "Квадратний корінь"

#: ../../Ch06/Ch06_DataHandling_4.rst:23
msgid "``SQRT(x)``"
msgstr "``SQRT(x)``"

#: ../../Ch06/Ch06_DataHandling_4.rst:23
msgid "``SQRT(25)``"
msgstr "``SQRT(25)``"

#: ../../Ch06/Ch06_DataHandling_4.rst:23
msgid "5"
msgstr "5"

#: ../../Ch06/Ch06_DataHandling_4.rst:25
msgid "Absolute value"
msgstr "Абсолютне значення"

#: ../../Ch06/Ch06_DataHandling_4.rst:25
msgid "``ABS(x)``"
msgstr "``ABS(x)``"

#: ../../Ch06/Ch06_DataHandling_4.rst:25
msgid "``ABS(-23)``"
msgstr "``ABS(-23)``"

#: ../../Ch06/Ch06_DataHandling_4.rst:25
msgid "23"
msgstr "23"

#: ../../Ch06/Ch06_DataHandling_4.rst:27
msgid "Logarithm (base 10)"
msgstr "Логарифм (за основою 10)"

#: ../../Ch06/Ch06_DataHandling_4.rst:27
msgid "``LOG10(x)``"
msgstr "``LOG10(x)``"

#: ../../Ch06/Ch06_DataHandling_4.rst:27
msgid "``LOG10(1000)``"
msgstr "``LOG10(1000)``"

#: ../../Ch06/Ch06_DataHandling_4.rst:27
msgid "3"
msgstr "3"

#: ../../Ch06/Ch06_DataHandling_4.rst:30
msgid "Logarithm (base *e*)"
msgstr "Логарифм (з основою *e*)"

#: ../../Ch06/Ch06_DataHandling_4.rst:30
msgid "``LN(x)``"
msgstr "``LN(x)``"

#: ../../Ch06/Ch06_DataHandling_4.rst:30
msgid "``LN(1000)``"
msgstr "``LN(1000)``"

#: ../../Ch06/Ch06_DataHandling_4.rst:30
msgid "6.908"
msgstr "6.908"

#: ../../Ch06/Ch06_DataHandling_4.rst:33
msgid "Exponentiation"
msgstr "Піднесення до степеня"

#: ../../Ch06/Ch06_DataHandling_4.rst:33
msgid "``EXP(x)``"
msgstr "``EXP(x)``"

#: ../../Ch06/Ch06_DataHandling_4.rst:33
msgid "``EXP(6.908)``"
msgstr "``EXP(6.908)``"

#: ../../Ch06/Ch06_DataHandling_4.rst:33
msgid "1000.245"
msgstr "1000.245"

#: ../../Ch06/Ch06_DataHandling_4.rst:35
msgid "Box-Cox"
msgstr "Бокс-Кокс"

#: ../../Ch06/Ch06_DataHandling_4.rst:35
msgid "``BOXCOX(x, lamda)``"
msgstr "``BOXCOX(x, lamda)``"

#: ../../Ch06/Ch06_DataHandling_4.rst:35
msgid "``BOXCOX(6.908, 3)``"
msgstr "``BOXCOX(6.908, 3)``"

#: ../../Ch06/Ch06_DataHandling_4.rst:35
msgid "109.551"
msgstr "109.551"

#: ../../Ch06/Ch06_DataHandling_4.rst:37
msgid "Rounding to nearest"
msgstr "Округлення до найближчого"

#: ../../Ch06/Ch06_DataHandling_4.rst:37
msgid "``ROUND()``"
msgstr "``ROUND()``"

#: ../../Ch06/Ch06_DataHandling_4.rst:37
msgid "``ROUND(1.32)``"
msgstr "``ROUND(1.32)``"

#: ../../Ch06/Ch06_DataHandling_4.rst:37 ../../Ch06/Ch06_DataHandling_4.rst:40
msgid "1"
msgstr "1"

#: ../../Ch06/Ch06_DataHandling_4.rst:40
msgid "Rounding down"
msgstr "Округлення вниз"

#: ../../Ch06/Ch06_DataHandling_4.rst:40
msgid "``FLOOR()``"
msgstr "``FLOOR()``"

#: ../../Ch06/Ch06_DataHandling_4.rst:40
msgid "``FLOOR(1.32)``"
msgstr "``FLOOR(1.32)``"

#: ../../Ch06/Ch06_DataHandling_4.rst:42
msgid "Rounding up"
msgstr "Округлення в більшу сторону"

#: ../../Ch06/Ch06_DataHandling_4.rst:42
msgid "``CEILING()``"
msgstr "``CEILING()``"

#: ../../Ch06/Ch06_DataHandling_4.rst:42
msgid "``CEILING(1.32)``"
msgstr "``CEILING(1.32)``"

#: ../../Ch06/Ch06_DataHandling_4.rst:42
msgid "2"
msgstr "2"

#: ../../Ch06/Ch06_DataHandling_4.rst:47
msgid "Logarithms and exponentials"
msgstr "Логарифми та експоненти"

#: ../../Ch06/Ch06_DataHandling_4.rst:49
msgid ""
"As I’ve mentioned earlier, jamovi has an useful range of mathematical "
"functions built into it and there really wouldn’t be much point in trying to "
"describe or even list all of them. For the most part, I’ve focused only on "
"those functions that are strictly necessary for this book. However I do want "
"to make an exception for logarithms and exponentials. Although they aren’t "
"needed anywhere else in this book, they are *everywhere* in statistics more "
"broadly. And not only that, there are a *lot* of situations in which it is "
"convenient to analyse the logarithm of a variable (i.e., to take a “log-"
"transform” of the variable). I suspect that many (maybe most) readers of "
"this book will have encountered logarithms and exponentials before, but from "
"past experience I know that there’s a substantial proportion of students who "
"take a social science statistics class who haven’t touched logarithms since "
"high school, and would appreciate a bit of a refresher."
msgstr ""
"Як я вже згадував раніше, jamovi має вбудований набір корисних математичних "
"функцій, і немає сенсу описувати або навіть перелічувати їх усі. Здебільшого "
"я зосередився лише на тих функціях, які є строго необхідними для цієї книги. "
"Однак я хочу зробити виняток для логарифмів та експонент. Хоча вони не "
"потрібні в інших розділах цієї книги, вони *всюди* використовуються в "
"статистиці в більш широкому сенсі. І не тільки це, є *багато* ситуацій, в "
"яких зручно аналізувати логарифм змінної (тобто, проводити «логарифмічне "
"перетворення» змінної). Я підозрюю, що багато (можливо, більшість) читачів "
"цієї книги вже стикалися з логарифмами та експонентами, але з минулого "
"досвіду я знаю, що значна частина студентів, які вивчають статистику в "
"соціальних науках, не стикалися з логарифмами з часів середньої школи і були "
"б вдячні за невелике оновлення знань."

#: ../../Ch06/Ch06_DataHandling_4.rst:64
msgid ""
"In order to understand logarithms and exponentials, the easiest thing to do "
"is to actually calculate them and see how they relate to other simple "
"calculations. There are three jamovi functions in particular that I want to "
"talk about, namely ``LN()``, ``LOG10()`` and ``EXP()``. To start with, let’s "
"consider ``LOG10()``, which is known as the “logarithm in base 10”. The "
"trick to understanding a **logarithm** is to understand that it’s basically "
"the “opposite” of taking a power. Specifically, the logarithm in base 10 is "
"closely related to the powers of 10. So let’s start by noting that 10-cubed "
"is 1000. Mathematically, we would write this:"
msgstr ""
"Щоб зрозуміти логарифми та експоненти, найпростіше — це фактично обчислити "
"їх і подивитися, як вони пов'язані з іншими простими обчисленнями. Я хочу "
"розповісти про три функції jamovi, а саме ``LN()``, ``LOG10()`` та ``EXP()``"
". Для початку розглянемо ``LOG10()``, яка відома як «логарифм за основою 10»"
". Щоб зрозуміти **логарифм**, потрібно усвідомити, що він є, по суті, "
"«протилежністю» піднесення до степеня. Зокрема, логарифм за основою 10 тісно "
"пов'язаний зі степенями числа 10. Отже, почнемо з того, що 10 в кубі "
"дорівнює 1000. Математично це можна записати так:"

#: ../../Ch06/Ch06_DataHandling_4.rst:75
msgid "10³ = 1000"
msgstr "10³ = 1000"

#: ../../Ch06/Ch06_DataHandling_4.rst:77
msgid ""
"The trick to understanding a logarithm is to recognise that the statement "
"that “10 to the power of 3 is equal to 1000” is equivalent to the statement "
"that “the logarithm (in base 10) of 1000 is equal to 3”. Mathematically, we "
"write this as follows,"
msgstr ""
"Щоб зрозуміти логарифм, потрібно усвідомити, що твердження «10 у степені 3 "
"дорівнює 1000» еквівалентне твердженню «логарифм (за основою 10) числа 1000 "
"дорівнює 3». Математично це записується так,"

#: ../../Ch06/Ch06_DataHandling_4.rst:82
msgid "log\\ :sub:`10`\\(1000) = 3"
msgstr "log\\ :sub:`10`\\(1000) = 3"

#: ../../Ch06/Ch06_DataHandling_4.rst:84
msgid ""
"Okay, since the ``LOG10()`` function is related to the powers of 10, you "
"might expect that there are other logarithms (in bases other than 10) that "
"are related to other powers too. And of course that’s true: there’s not "
"really anything mathematically special about the number 10. You and I happen "
"to find it useful because decimal numbers are built around the number 10, "
"but the big bad world of mathematics scoffs at our decimal numbers. Sadly, "
"the universe doesn’t actually care how we write down numbers. Anyway, the "
"consequence of this cosmic indifference is that there’s nothing particularly "
"special about calculating logarithms in base 10. You could, for instance, "
"calculate your logarithms in base 2. Alternatively, a third type of "
"logarithm, and one we see a lot more of in statistics than either base 10 or "
"base 2, is called the **natural logarithm**, and corresponds to the "
"logarithm in base *e*. Since you might one day run into it, I’d better "
"explain what *e* is. The number *e*, known as **Euler’s number**, is one of "
"those annoying “irrational” numbers whose decimal expansion is infinitely "
"long, and is considered one of the most important numbers in mathematics. "
"The first few digits of *e* are:"
msgstr ""
"Оскільки функція ``LOG10()`` пов'язана зі степенями числа 10, можна "
"припустити, що існують й інші логарифми (з основою, відмінною від 10), які "
"також пов'язані зі степенями. І це, звичайно, правда: математично число 10 "
"не має нічого особливого. Ви і я вважаємо його корисним, тому що десяткові "
"числа побудовані навколо числа 10, але великий і страшний світ математики "
"зневажає наші десяткові числа. На жаль, всесвіту насправді байдуже, як ми "
"записуємо числа. У будь-якому разі, наслідком цієї космічної байдужості є "
"те, що в обчисленні логарифмів з основою 10 немає нічого особливого. "
"Наприклад, ви можете обчислювати логарифми в системі числення з основою 2. "
"Крім того, існує третій тип логарифмів, який ми бачимо в статистиці набагато "
"частіше, ніж логарифми з основою 10 або 2. Він називається **натуральним "
"логарифмом** і відповідає логарифму в системі числення з основою *e*. "
"Оскільки ви можете одного дня зіткнутися з ним, я краще поясню, що таке *e*. "
"Число *e*, відоме як **число Ейлера**, є одним із тих дратівливих "
"«ірраціональних» чисел, десятковий розклад яких є нескінченно довгим, і "
"вважається одним із найважливіших чисел у математиці. Перші кілька цифр *e* "
"такі:"

#: ../../Ch06/Ch06_DataHandling_4.rst:102
msgid "*e* = 2.718282"
msgstr "*e* = 2.718282"

#: ../../Ch06/Ch06_DataHandling_4.rst:104
msgid ""
"There are quite a few situation in statistics that require us to calculate "
"powers of *e*, though none of them appear in this book. Raising *e* to the "
"power *x* is called the **exponential** of *x*, and so it’s very common to "
"see e\\ :sup:`x` written as *exp(x)*. And so it’s no surprise that jamovi "
"has a function that calculates exponentials, called ``EXP()``. Because the "
"number *e* crops up so often in statistics, the natural logarithm (i.e., "
"logarithm in base *e*) also tends to turn up. Mathematicians often write it "
"as log\\ :sub:`e`\\ (x) or *ln(x)*. In fact, jamovi works the same way: the "
"``LN()`` function corresponds to the natural logarithm."
msgstr ""
"У статистиці є чимало ситуацій, які вимагають від нас обчислення степенів *e*"
", хоча жодна з них не згадується в цій книзі. Піднесення *e* до степеня *x* "
"називається **експонентою** *x*, тому дуже часто e\\ :sup:`x` записується як "
"*exp(x)*. Тому не дивно, що jamovi має функцію, яка обчислює експоненти, яка "
"називається ``EXP()``. Оскільки число *e* так часто зустрічається в "
"статистиці, природний логарифм (тобто логарифм за основою *e*) також часто "
"зустрічається. Математики часто записують його як log\\ :sub:`e`\\ (x) або "
"*ln(x)*. Насправді jamovi працює так само: функція ``LN()`` відповідає "
"натуральному логарифму."

#: ../../Ch06/Ch06_DataHandling_4.rst:115
msgid ""
"And with that, I think we’ve had quite enough exponentials and logarithms "
"for this book!"
msgstr ""
"І з огляду на це, я думаю, що у нас було цілком достатньо експоненціальних "
"та логарифмічних функцій для цієї книги!"

#: ../../Ch06/Ch06_DataHandling_4.rst:121
msgid "We’ll leave the box-cox function until :ref:`later on <box-cox>`."
msgstr ""

#: ../../Ch06/Ch06_DataHandling_5.rst:4
msgid "Extracting a subset of the data"
msgstr ""

#: ../../Ch06/Ch06_DataHandling_5.rst:6
msgid ""
"One very important kind of data handling is being able to extract a "
"particular subset of the data. For instance, you might be interested only in "
"analysing the data from one experimental condition, or you may want to look "
"closely at the data from people over 50 years in age. To do this, the first "
"step is getting jamovi to filter the subset of the data corresponding to the "
"observations that you’re interested in."
msgstr ""

#: ../../Ch06/Ch06_DataHandling_5.rst:13
msgid ""
"This section returns to the |nightgarden|_ data set. If you’re reading this "
"whole chapter in one sitting, then you should already have this data set "
"loaded into a jamovi window. For this section, let’s focus on the two "
"variables ``speaker`` and ``utterance`` (see :doc:`Ch06_DataHandling_1` if "
"you’ve forgotten what those variables look like). Suppose that what I want "
"to do is pull out only those utterances that were made by ``makka-pakka``. "
"To that end, we need to specify a filter in jamovi. First open up a filter "
"window by clicking on ``Filters`` on the main jamovi ``Data`` toolbar. Then, "
"in the ``Filter 1`` text box, next to the ``=`` sign, type the following:"
msgstr ""

#: ../../Ch06/Ch06_DataHandling_5.rst:27
msgid ""
"When you have done this, you will see that a new column has been added to "
"the spreadsheet window (see :numref:`fig-subset1`), labelled ``Filter 1``, "
"with the cases where ``speaker`` is not ``makka-pakka`` greyed-out (i.e., "
"filtered out) and, conversely, the cases where ``speaker`` is ``makka-"
"pakka`` have a green check mark indicating they are filtered in. You can "
"test this by running ``Exploration`` → ``Descriptives``, assigning "
"``speaker`` to the ``Variables``- box and checking ``Frequency tables``. Go "
"on, try it, and see what that shows!"
msgstr ""

#: ../../Ch06/Ch06_DataHandling_5.rst:37
msgid "Creating a subset using ``Filters``"
msgstr "Створення підмножини за допомогою ``Filters``"

#: ../../Ch06/Ch06_DataHandling_5.rst:41
msgid ""
"Creating a subset of the |nightgarden|_ data set using the jamovi "
"``Filters`` option"
msgstr ""

#: ../../Ch06/Ch06_DataHandling_5.rst:46
msgid ""
"Following on from this simple example, you can also build up more complex "
"filters using logical expressions in jamovi. For instance, suppose I wanted "
"to keep only those cases when the utterance is either ``pip`` or ``oo``. In "
"this case in the ``Filter 1`` text box, next to the ``=`` sign, you would "
"type the following:"
msgstr ""
